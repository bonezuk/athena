#include "gtest/gtest.h"

#include "engine/inc/FormatTypeFromFloat.h"
#include "audioio/inc/SampleConverter.h"

using namespace omega;
using namespace audioio;
using namespace testing;

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,isNotSupported)
{
    SampleConverter sampleConverterA(9,1,true,false,true);
	EXPECT_FALSE(sampleConverterA.isSupported());

    SampleConverter sampleConverterB(32,5,true,false,true);
    EXPECT_FALSE(sampleConverterB.isSupported());

    SampleConverter sampleConverterC(64,4,true,false,true);
    EXPECT_FALSE(sampleConverterC.isSupported());
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,constructorDefault)
{
	SampleConverter sampleConverter;
	EXPECT_TRUE(sampleConverter.isLittleEndian());
	EXPECT_FALSE(sampleConverter.isAlignedHigh());
	EXPECT_EQ(16,sampleConverter.bits());
	EXPECT_EQ(2,sampleConverter.bytesPerSample());	
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,constructorCopy)
{
    SampleConverter sampleConverterA(9,1,true,false,true);
	SampleConverter sampleConverterB(sampleConverterA);
	EXPECT_TRUE(sampleConverterB.isLittleEndian());
	EXPECT_FALSE(sampleConverterB.isAlignedHigh());
	EXPECT_EQ(9,sampleConverterB.bits());
	EXPECT_EQ(1,sampleConverterB.bytesPerSample());
    EXPECT_EQ(1,sampleConverterB.numberOfInputChannels());
    EXPECT_EQ(1,sampleConverterB.numberOfOutputChannels());
	
    SampleConverter sampleConverterC(24,3,false,true,true);
	sampleConverterC.setNumberOfInputChannels(3);
	sampleConverterC.setNumberOfOutputChannels(8);
	
    SampleConverter sampleConverterD(sampleConverterC);
    EXPECT_FALSE(sampleConverterD.isLittleEndian());
    EXPECT_TRUE(sampleConverterD.isAlignedHigh());
    EXPECT_EQ(24,sampleConverterD.bits());
    EXPECT_EQ(3,sampleConverterD.bytesPerSample());
    EXPECT_EQ(3,sampleConverterD.numberOfInputChannels());
    EXPECT_EQ(8,sampleConverterD.numberOfOutputChannels());
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,equalityOperator)
{
    SampleConverter sampleConverterA(9,1,true,false,true);
	SampleConverter sampleConverterB;
	sampleConverterB = sampleConverterA;
	EXPECT_TRUE(sampleConverterB.isLittleEndian());
	EXPECT_FALSE(sampleConverterB.isAlignedHigh());
	EXPECT_EQ(9,sampleConverterB.bits());
	EXPECT_EQ(1,sampleConverterB.bytesPerSample());
    EXPECT_EQ(1,sampleConverterB.numberOfInputChannels());
    EXPECT_EQ(1,sampleConverterB.numberOfOutputChannels());
	
    SampleConverter sampleConverterC(24,3,false,true,true);
	sampleConverterC.setNumberOfInputChannels(3);
	sampleConverterC.setNumberOfOutputChannels(8);
		
	SampleConverter sampleConverterD;
	sampleConverterD = sampleConverterC;
	
    EXPECT_FALSE(sampleConverterD.isLittleEndian());
    EXPECT_TRUE(sampleConverterD.isAlignedHigh());
    EXPECT_EQ(24,sampleConverterD.bits());
    EXPECT_EQ(3,sampleConverterD.numberOfInputChannels());
    EXPECT_EQ(8,sampleConverterD.numberOfOutputChannels());
}

//-------------------------------------------------------------------------------------------

tint isSampleEquiv(tuint32 a,tuint32 b,tint N)
{
	tint r = 0;

	if(a==b || a==b-1 || a==b+1|| a==b-2 || a==b+2)
	{
		r = 1;
	}
	else if(N==3 && (((a==0x00800000 || a==0) && b==0x00ffffff) || ((b==0x00800000 || b==0) && a==0x00ffffff)))
	{
		r = 1;
	}
	return r;
}

void testSampleOutputConvertion(const tubyte *expect,const tubyte *out,tint noBits,tint bytesPerSample,tint noSamples)
{
#if defined(SINGLE_FLOAT_SAMPLE)
	if(bytesPerSample>=3)
	{
		const tint N = 3;
		const tubyte *x,*y;
		
		x = expect;
		y = out;
		for(int i=0;i<noSamples;i++)
		{
			tuint32 a,b,r = 0;
			
			a = 0;
			b = 0;
			for(int j=0;j<N;j++)
			{
				a |= static_cast<tuint32>(x[j]) << (j * 8);
				b |= static_cast<tuint32>(y[j]) << (j * 8);
			}
			r |= isSampleEquiv(a,b,N);

			a = 0;
			b = 0;
			for(int j=0;j<N;j++)
			{
				a |= static_cast<tuint32>(x[j]) << ((N-(j+1)) * 8);
				b |= static_cast<tuint32>(y[j]) << ((N-(j+1)) * 8);
			}
			r |= isSampleEquiv(a,b,N);

			a = 0;
			b = 0;
			for(int j=0;j<N;j++)
			{
				a |= static_cast<tuint32>(x[bytesPerSample-(j+1)]) << (j * 8);
				b |= static_cast<tuint32>(y[bytesPerSample-(j+1)]) << (j * 8);
			}
			r |= isSampleEquiv(a,b,N);

			a = 0;
			b = 0;
			for(int j=0;j<N;j++)
			{
				a |= static_cast<tuint32>(x[bytesPerSample-(j+1)]) << ((N-(j+1)) * 8);
				b |= static_cast<tuint32>(y[bytesPerSample-(j+1)]) << ((N-(j+1)) * 8);
			}
			r |= isSampleEquiv(a,b,N);

			if(!r)
			{
				int c =0;
			}
			EXPECT_TRUE(r);
			
			x += bytesPerSample;
			y += bytesPerSample;
		}
	}
	else
	{
		EXPECT_EQ(0,memcmp(expect,out,12 * bytesPerSample));
	}
#else
	EXPECT_EQ(0,memcmp(expect,out,12 * bytesPerSample));
#endif
}

//-------------------------------------------------------------------------------------------

void testSampleConvertion(tint noBits,tint bytesPerSample,bool littleEndian,bool alignHigh,const sample_t *samples,const tubyte *expect)
{
    tubyte *out = new tubyte [12 * bytesPerSample];
	
	SampleConverter sampleConverter(noBits,bytesPerSample,littleEndian,alignHigh,true);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataSignedInteger,sampleConverter.type());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(samples,out,12);
	
	testSampleOutputConvertion(expect,out,noBits,bytesPerSample,12);
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

void testSampleUnsignedConvertion(tint noBits,tint bytesPerSample,bool littleEndian,bool alignHigh,const sample_t *samples,const tubyte *expect)
{
    tubyte *out = new tubyte [12 * bytesPerSample];
	
	SampleConverter sampleConverter(noBits,bytesPerSample,littleEndian,alignHigh,false);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataUnsignedInteger,sampleConverter.type());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(samples,out,12);

    testSampleOutputConvertion(expect,out,noBits,bytesPerSample,12);
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

void createExpectedDoubleOutput(const sample_t *input,tfloat64 *sampleExpect,tint noSamples)
{
	for(int i=0;i<noSamples;i++)
	{
		sampleExpect[i] = static_cast<tfloat64>(input[i]);
	}
}

TEST(SampleConverter,doubleSamplesToDoubleLittleEndian)
{
#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	tfloat64 sampleExpect[12];
	createExpectedDoubleOutput(c_sampleInput,sampleExpect,12);
	
	tbyte expect[12 * 8];
	engine::writeNative64BitsAsLittleEndian(reinterpret_cast<const tbyte*>(sampleExpect),expect,12);
	
	tubyte *out = new tubyte [12 * sizeof(tfloat64)];
	
	SampleConverter sampleConverter(false,true);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_TRUE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataFloatDouble,sampleConverter.type());
	EXPECT_EQ(true,sampleConverter.isLittleEndian());
	EXPECT_EQ(false,sampleConverter.isAlignedHigh());
	EXPECT_EQ(64,sampleConverter.bits());
	EXPECT_EQ(8,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(c_sampleInput,out,12);
	
	EXPECT_EQ(0,memcmp(expect,out,12 * sizeof(tfloat64)));
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesToDoubleBigEndian)
{
#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	tfloat64 sampleExpect[12];
	createExpectedDoubleOutput(c_sampleInput,sampleExpect,12);
	
	tbyte expect[12 * 8];
    engine::writeNative64BitsAsBigEndian(reinterpret_cast<const tbyte*>(sampleExpect),expect,12);
	
    tubyte *out = new tubyte [12 * sizeof(tfloat64)];

	SampleConverter sampleConverter(false,false);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_TRUE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataFloatDouble,sampleConverter.type());
	EXPECT_EQ(false,sampleConverter.isLittleEndian());
	EXPECT_EQ(false,sampleConverter.isAlignedHigh());
	EXPECT_EQ(64,sampleConverter.bits());
	EXPECT_EQ(8,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(c_sampleInput,out,12);
	
	EXPECT_EQ(0,memcmp(expect,out,12 * sizeof(tfloat64)));
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesToFloatLittleEndian)
{
#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tfloat32 c_sampleSingle[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};	
	tbyte expect[12 * 4];
	engine::writeNative32BitsAsLittleEndian(reinterpret_cast<const tbyte*>(c_sampleSingle),expect,12);
	
    tubyte *out = new tubyte [12 * sizeof(tfloat32)];
	
	SampleConverter sampleConverter(true,true);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_TRUE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataFloatSingle,sampleConverter.type());
	EXPECT_EQ(true,sampleConverter.isLittleEndian());
	EXPECT_EQ(false,sampleConverter.isAlignedHigh());
	EXPECT_EQ(32,sampleConverter.bits());
	EXPECT_EQ(4,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(c_sampleInput,out,12);
	
	EXPECT_EQ(0,memcmp(expect,out,12 * sizeof(tfloat32)));
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesToFloatBigEndian)
{
#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tfloat32 c_sampleSingle[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
	tbyte expect[12 * 4];
	engine::writeNative32BitsAsBigEndian(reinterpret_cast<const tbyte*>(c_sampleSingle),expect,12);
	
    tubyte *out = new tubyte [12 * sizeof(tfloat32)];
	
	SampleConverter sampleConverter(true,false);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_TRUE(sampleConverter.isFloat());
	
	EXPECT_EQ(FormatDescription::e_DataFloatSingle,sampleConverter.type());
	EXPECT_EQ(false,sampleConverter.isLittleEndian());
	EXPECT_EQ(false,sampleConverter.isAlignedHigh());
	EXPECT_EQ(32,sampleConverter.bits());
	EXPECT_EQ(4,sampleConverter.bytesPerSample());
	EXPECT_EQ(1,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(1,sampleConverter.numberOfOutputChannels());
	
	sampleConverter.convert(c_sampleInput,out,12);
	
	EXPECT_EQ(0,memcmp(expect,out,12 * sizeof(tfloat32)));
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------
// 3-Bits
//  1.0 0x00000003 0x00000006
//  0.8 0x00000002 0x00000004
//  0.6 0x00000002 0x00000004
//  0.4 0x00000001 0x00000002
//  0.2 0x00000001 0x00000002
// -0.2 0xffffffff 0xfffffffe
// -0.4 0xfffffffe 0xfffffffc
// -0.6 0xfffffffe 0xfffffffc
// -0.8 0xfffffffd 0xfffffffa
// -1.0 0xfffffffc 0xfffffff8
//  1.2 0x00000003 0x00000006
// -1.2 0xfffffffc 0xfffffff8
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleIn8BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03,
		0x02,
		0x02,
		0x01,
		0x01,
		0xff,
		0xfe,
		0xfe,
		0xfd,
		0xfc,
		0x03,
		0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleIn8BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x60,
		0x40,
		0x40,
		0x20,
		0x20,
		0xe0,
		0xc0,
		0xc0,
		0xa0,
		0x80,
		0x60,
		0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0x00,
		0x02, 0x00,
		0x02, 0x00,
		0x01, 0x00,
		0x01, 0x00,
		0xff, 0xff,
		0xfe, 0xff,
		0xfe, 0xff,
		0xfd, 0xff,
		0xfc, 0xff,
		0x03, 0x00,
		0xfc, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x60,
		0x00, 0x40,
		0x00, 0x40,
		0x00, 0x20,
		0x00, 0x20,
		0x00, 0xe0,
		0x00, 0xc0,
		0x00, 0xc0,
		0x00, 0xa0,
		0x00, 0x80,
		0x00, 0x60,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x03,
		0x00, 0x02,
		0x00, 0x02,
		0x00, 0x01,
		0x00, 0x01,
		0xff, 0xff,
		0xff, 0xfe,
		0xff, 0xfe,
		0xff, 0xfd,
		0xff, 0xfc,
		0x00, 0x03,
		0xff, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x60, 0x00,
		0x40, 0x00,
		0x40, 0x00,
		0x20, 0x00,
		0x20, 0x00,
		0xe0, 0x00,
		0xc0, 0x00,
		0xc0, 0x00,
		0xa0, 0x00,
		0x80, 0x00,
		0x60, 0x00,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0x00, 0x00,
		0x02, 0x00, 0x00,
		0x02, 0x00, 0x00,
		0x01, 0x00, 0x00,
		0x01, 0x00, 0x00,
		0xff, 0xff, 0xff,
		0xfe, 0xff, 0xff,
		0xfe, 0xff, 0xff,
		0xfd, 0xff, 0xff,
		0xfc, 0xff, 0xff,
		0x03, 0x00, 0x00,
		0xfc, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x60,
		0x00, 0x00, 0x40,
		0x00, 0x00, 0x40,
		0x00, 0x00, 0x20,
		0x00, 0x00, 0x20,
		0x00, 0x00, 0xe0,
		0x00, 0x00, 0xc0,
		0x00, 0x00, 0xc0,
		0x00, 0x00, 0xa0,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x60,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x03,
		0x00, 0x00, 0x02,
		0x00, 0x00, 0x02,
		0x00, 0x00, 0x01,
		0x00, 0x00, 0x01,
		0xff, 0xff, 0xff,
		0xff, 0xff, 0xfe,
		0xff, 0xff, 0xfe,
		0xff, 0xff, 0xfd,
		0xff, 0xff, 0xfc,
		0x00, 0x00, 0x03,
		0xff, 0xff, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x60, 0x00, 0x00,
		0x40, 0x00, 0x00,
		0x40, 0x00, 0x00,
		0x20, 0x00, 0x00,
		0x20, 0x00, 0x00,
		0xe0, 0x00, 0x00,
		0xc0, 0x00, 0x00,
		0xc0, 0x00, 0x00,
		0xa0, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x60, 0x00, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff,
		0xfe, 0xff, 0xff, 0xff,
		0xfe, 0xff, 0xff, 0xff,
		0xfd, 0xff, 0xff, 0xff,
		0xfc, 0xff, 0xff, 0xff,
		0x03, 0x00, 0x00, 0x00,
		0xfc, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x60,
		0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x20,
		0x00, 0x00, 0x00, 0x20,
		0x00, 0x00, 0x00, 0xe0,
		0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0xa0,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x60,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x01,
		0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xfe,
		0xff, 0xff, 0xff, 0xfe,
		0xff, 0xff, 0xff, 0xfd,
		0xff, 0xff, 0xff, 0xfc,
		0x00, 0x00, 0x00, 0x03,
		0xff, 0xff, 0xff, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo3BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 3;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x60, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 4-Bits
//  1.0 0x00000007 0x00000070
//  0.8 0x00000006 0x00000060
//  0.6 0x00000004 0x00000040
//  0.4 0x00000003 0x00000030
//  0.2 0x00000001 0x00000010
// -0.2 0xfffffffe 0xffffffe0
// -0.4 0xfffffffd 0xffffffd0
// -0.6 0xfffffffb 0xffffffb0
// -0.8 0xfffffffa 0xffffffa0
// -1.0 0xfffffff8 0xffffff80
//  1.0 0x00000007 0x00000070
// -1.0 0xfffffff8 0xffffff80
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleIn8BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07,
		0x06,
		0x04,
		0x03,
		0x01,
		0xfe,
		0xfd,
		0xfb,
		0xfa,
		0xf8,
		0x07,
		0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleIn8BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x70,
		0x60,
		0x40,
		0x30,
		0x10,
		0xe0,
		0xd0,
		0xb0,
		0xa0,
		0x80,
		0x70,
		0x80
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0x00,
		0x06, 0x00,
		0x04, 0x00,
		0x03, 0x00,
		0x01, 0x00,
		0xfe, 0xff,
		0xfd, 0xff,
		0xfb, 0xff,
		0xfa, 0xff,
		0xf8, 0xff,
		0x07, 0x00,
		0xf8, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x70,
		0x00, 0x60,
		0x00, 0x40,
		0x00, 0x30,
		0x00, 0x10,
		0x00, 0xe0,
		0x00, 0xd0,
		0x00, 0xb0,
		0x00, 0xa0,
		0x00, 0x80,
		0x00, 0x70,
		0x00, 0x80
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x07,
		0x00, 0x06,
		0x00, 0x04,
		0x00, 0x03,
		0x00, 0x01,
		0xff, 0xfe,
		0xff, 0xfd, 
		0xff, 0xfb,
		0xff, 0xfa,
		0xff, 0xf8,
		0x00, 0x07,
		0xff, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x70, 0x00,
		0x60, 0x00,
		0x40, 0x00,
		0x30, 0x00,
		0x10, 0x00,
		0xe0, 0x00,
		0xd0, 0x00,
		0xb0, 0x00,
		0xa0, 0x00,
		0x80, 0x00,
		0x70, 0x00,
		0x80, 0x00
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0x00, 0x00,
		0x06, 0x00, 0x00,
		0x04, 0x00, 0x00,
		0x03, 0x00, 0x00,
		0x01, 0x00, 0x00,
		0xfe, 0xff, 0xff,
		0xfd, 0xff, 0xff,
		0xfb, 0xff, 0xff,
		0xfa, 0xff, 0xff,
		0xf8, 0xff, 0xff,
		0x07, 0x00, 0x00,
		0xf8, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x70,
		0x00, 0x00, 0x60,
		0x00, 0x00, 0x40,
		0x00, 0x00, 0x30,
		0x00, 0x00, 0x10,
		0x00, 0x00, 0xe0,
		0x00, 0x00, 0xd0,
		0x00, 0x00, 0xb0,
		0x00, 0x00, 0xa0,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x70,
		0x00, 0x00, 0x80
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x07,
		0x00, 0x00, 0x06,
		0x00, 0x00, 0x04,
		0x00, 0x00, 0x03,
		0x00, 0x00, 0x01,
		0xff, 0xff, 0xfe,
		0xff, 0xff, 0xfd, 
		0xff, 0xff, 0xfb,
		0xff, 0xff, 0xfa,
		0xff, 0xff, 0xf8,
		0x00, 0x00, 0x07,
		0xff, 0xff, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x70, 0x00, 0x00,
		0x60, 0x00, 0x00,
		0x40, 0x00, 0x00,
		0x30, 0x00, 0x00,
		0x10, 0x00, 0x00,
		0xe0, 0x00, 0x00,
		0xd0, 0x00, 0x00,
		0xb0, 0x00, 0x00,
		0xa0, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x70, 0x00, 0x00,
		0x80, 0x00, 0x00
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff, 0xff,
		0xfd, 0xff, 0xff, 0xff,
		0xfb, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff,
		0xf8, 0xff, 0xff, 0xff,
		0x07, 0x00, 0x00, 0x00,
		0xf8, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x70,
		0x00, 0x00, 0x00, 0x60,
		0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x30,
		0x00, 0x00, 0x00, 0x10,
		0x00, 0x00, 0x00, 0xe0,
		0x00, 0x00, 0x00, 0xd0,
		0x00, 0x00, 0x00, 0xb0,
		0x00, 0x00, 0x00, 0xa0,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x70,
		0x00, 0x00, 0x00, 0x80
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x07,
		0x00, 0x00, 0x00, 0x06,
		0x00, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x03,
		0x00, 0x00, 0x00, 0x01,
		0xff, 0xff, 0xff, 0xfe,
		0xff, 0xff, 0xff, 0xfd, 
		0xff, 0xff, 0xff, 0xfb,
		0xff, 0xff, 0xff, 0xfa,
		0xff, 0xff, 0xff, 0xf8,
		0x00, 0x00, 0x00, 0x07,
		0xff, 0xff, 0xff, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo4BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 4;
    const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x70, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00,
		0x10, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x70, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};	
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 5-Bits
//  1.0 0x0000000f 0x00000078
//  0.8 0x0000000c 0x00000060
//  0.6 0x00000009 0x00000048
//  0.4 0x00000006 0x00000030
//  0.2 0x00000003 0x00000018
// -0.2 0xfffffffd 0xffffffe8
// -0.4 0xfffffffa 0xffffffd0
// -0.6 0xfffffff6 0xffffffb0
// -0.8 0xfffffff3 0xffffff98
// -1.0 0xfffffff0 0xffffff80
//  1.0 0x0000000f 0x00000078
// -1.0 0xfffffff0 0xffffff80
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleIn8BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f,
		0x0c,
		0x09,
		0x06,
		0x03,
		0xfd,
		0xfa,
		0xf6,
		0xf3,
		0xf0,
		0x0f,
		0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleIn8BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x78,
		0x60,
		0x48,
		0x30,
		0x18,
		0xe8,
		0xd0,
		0xb0,
		0x98,
		0x80,
		0x78,
		0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0x00,
		0x0c, 0x00,
		0x09, 0x00,
		0x06, 0x00,
		0x03, 0x00,
		0xfd, 0xff,
		0xfa, 0xff,
		0xf6, 0xff,
		0xf3, 0xff,
		0xf0, 0xff,
		0x0f, 0x00,
		0xf0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x78,
		0x00, 0x60,
		0x00, 0x48,
		0x00, 0x30,
		0x00, 0x18,
		0x00, 0xe8,
		0x00, 0xd0,
		0x00, 0xb0,
		0x00, 0x98,
		0x00, 0x80,
		0x00, 0x78,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x0f,
		0x00, 0x0c,
		0x00, 0x09,
		0x00, 0x06,
		0x00, 0x03,
		0xff, 0xfd,
		0xff, 0xfa,
		0xff, 0xf6,
		0xff, 0xf3,
		0xff, 0xf0,
		0x00, 0x0f,
		0xff, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x78, 0x00,
		0x60, 0x00,
		0x48, 0x00,
		0x30, 0x00,
		0x18, 0x00,
		0xe8, 0x00,
		0xd0, 0x00,
		0xb0, 0x00,
		0x98, 0x00,
		0x80, 0x00,
		0x78, 0x00,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0x00, 0x00,
		0x0c, 0x00, 0x00,
		0x09, 0x00, 0x00,
		0x06, 0x00, 0x00,
		0x03, 0x00, 0x00,
		0xfd, 0xff, 0xff,
		0xfa, 0xff, 0xff,
		0xf6, 0xff, 0xff,
		0xf3, 0xff, 0xff,
		0xf0, 0xff, 0xff,
		0x0f, 0x00, 0x00,
		0xf0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x78,
		0x00, 0x00, 0x60,
		0x00, 0x00, 0x48,
		0x00, 0x00, 0x30,
		0x00, 0x00, 0x18,
		0x00, 0x00, 0xe8,
		0x00, 0x00, 0xd0,
		0x00, 0x00, 0xb0,
		0x00, 0x00, 0x98,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x78,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x0f,
		0x00, 0x00, 0x0c,
		0x00, 0x00, 0x09,
		0x00, 0x00, 0x06,
		0x00, 0x00, 0x03,
		0xff, 0xff, 0xfd,
		0xff, 0xff, 0xfa,
		0xff, 0xff, 0xf6,
		0xff, 0xff, 0xf3,
		0xff, 0xff, 0xf0,
		0x00, 0x00, 0x0f,
		0xff, 0xff, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x78, 0x00, 0x00,
		0x60, 0x00, 0x00,
		0x48, 0x00, 0x00,
		0x30, 0x00, 0x00,
		0x18, 0x00, 0x00,
		0xe8, 0x00, 0x00,
		0xd0, 0x00, 0x00,
		0xb0, 0x00, 0x00,
		0x98, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x78, 0x00, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00,
		0x09, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00,
		0xfd, 0xff, 0xff, 0xff,
		0xfa, 0xff, 0xff, 0xff,
		0xf6, 0xff, 0xff, 0xff,
		0xf3, 0xff, 0xff, 0xff,
		0xf0, 0xff, 0xff, 0xff,
		0x0f, 0x00, 0x00, 0x00,
		0xf0, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x78,
		0x00, 0x00, 0x00, 0x60,
		0x00, 0x00, 0x00, 0x48,
		0x00, 0x00, 0x00, 0x30,
		0x00, 0x00, 0x00, 0x18,
		0x00, 0x00, 0x00, 0xe8,
		0x00, 0x00, 0x00, 0xd0,
		0x00, 0x00, 0x00, 0xb0,
		0x00, 0x00, 0x00, 0x98,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x78,
		0x00, 0x00, 0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 5;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x0f,
		0x00, 0x00, 0x00, 0x0c,
		0x00, 0x00, 0x00, 0x09,
		0x00, 0x00, 0x00, 0x06,
		0x00, 0x00, 0x00, 0x03,
		0xff, 0xff, 0xff, 0xfd,
		0xff, 0xff, 0xff, 0xfa,
		0xff, 0xff, 0xff, 0xf6,
		0xff, 0xff, 0xff, 0xf3,
		0xff, 0xff, 0xff, 0xf0,
		0x00, 0x00, 0x00, 0x0f,
		0xff, 0xff, 0xff, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo5BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 5;
    const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x78, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00,
		0x18, 0x00, 0x00, 0x00,
		0xe8, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00,
		0x98, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x78, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 6-Bits
//  1.0 0x0000001f 0x0000007c
//  0.8 0x00000019 0x00000064
//  0.6 0x00000013 0x0000004c
//  0.4 0x0000000c 0x00000030
//  0.2 0x00000006 0x00000018
// -0.2 0xfffffffa 0xffffffe8
// -0.4 0xfffffff3 0xffffffcc
// -0.6 0xffffffed 0xffffffb4
// -0.8 0xffffffe6 0xffffff98
// -1.0 0xffffffe0 0xffffff80
//  1.0 0x0000001f 0x0000007c
// -1.0 0xffffffe0 0xffffff80
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleIn8BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f,
		0x19,
		0x13,
		0x0c,
		0x06,
		0xfa,
		0xf3,
		0xed,
		0xe6,
		0xe0,
		0x1f,
		0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleIn8BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7c,
		0x64,
		0x4c,
		0x30,
		0x18,
		0xe8,
		0xcc,
		0xb4,
		0x98,
		0x80,
		0x7c,
		0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0x00,
		0x19, 0x00,
		0x13, 0x00,
		0x0c, 0x00,
		0x06, 0x00,
		0xfa, 0xff,
		0xf3, 0xff,
		0xed, 0xff,
		0xe6, 0xff,
		0xe0, 0xff,
		0x1f, 0x00,
		0xe0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7c,
		0x00, 0x64,
		0x00, 0x4c,
		0x00, 0x30,
		0x00, 0x18,
		0x00, 0xe8,
		0x00, 0xcc,
		0x00, 0xb4,
		0x00, 0x98,
		0x00, 0x80,
		0x00, 0x7c,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x1f,
		0x00, 0x19,
		0x00, 0x13,
		0x00, 0x0c,
		0x00, 0x06,
		0xff, 0xfa,
		0xff, 0xf3,
		0xff, 0xed,
		0xff, 0xe6,
		0xff, 0xe0,
		0x00, 0x1f,
		0xff, 0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7c, 0x00,
		0x64, 0x00,
		0x4c, 0x00,
		0x30, 0x00,
		0x18, 0x00,
		0xe8, 0x00,
		0xcc, 0x00,
		0xb4, 0x00,
		0x98, 0x00,
		0x80, 0x00,
		0x7c, 0x00,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0x00, 0x00,
		0x19, 0x00, 0x00,
		0x13, 0x00, 0x00,
		0x0c, 0x00, 0x00,
		0x06, 0x00, 0x00,
		0xfa, 0xff, 0xff,
		0xf3, 0xff, 0xff,
		0xed, 0xff, 0xff,
		0xe6, 0xff, 0xff,
		0xe0, 0xff, 0xff,
		0x1f, 0x00, 0x00,
		0xe0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x7c,
		0x00, 0x00, 0x64,
		0x00, 0x00, 0x4c,
		0x00, 0x00, 0x30,
		0x00, 0x00, 0x18,
		0x00, 0x00, 0xe8,
		0x00, 0x00, 0xcc,
		0x00, 0x00, 0xb4,
		0x00, 0x00, 0x98,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x7c,
		0x00, 0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x1f,
		0x00, 0x00, 0x19,
		0x00, 0x00, 0x13,
		0x00, 0x00, 0x0c,
		0x00, 0x00, 0x06,
		0xff, 0xff, 0xfa,
		0xff, 0xff, 0xf3,
		0xff, 0xff, 0xed,
		0xff, 0xff, 0xe6,
		0xff, 0xff, 0xe0,
		0x00, 0x00, 0x1f,
		0xff, 0xff, 0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7c, 0x00, 0x00,
		0x64, 0x00, 0x00,
		0x4c, 0x00, 0x00,
		0x30, 0x00, 0x00,
		0x18, 0x00, 0x00,
		0xe8, 0x00, 0x00,
		0xcc, 0x00, 0x00,
		0xb4, 0x00, 0x00,
		0x98, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x7c, 0x00, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00,
		0x13, 0x00, 0x00, 0x00,
		0x0c, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00,
		0xfa, 0xff, 0xff, 0xff,
		0xf3, 0xff, 0xff, 0xff,
		0xed, 0xff, 0xff, 0xff,
		0xe6, 0xff, 0xff, 0xff,
		0xe0, 0xff, 0xff, 0xff,
		0x1f, 0x00, 0x00, 0x00,
		0xe0, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7c,
		0x00, 0x00, 0x00, 0x64,
		0x00, 0x00, 0x00, 0x4c,
		0x00, 0x00, 0x00, 0x30,
		0x00, 0x00, 0x00, 0x18,
		0x00, 0x00, 0x00, 0xe8,
		0x00, 0x00, 0x00, 0xcc,
		0x00, 0x00, 0x00, 0xb4,
		0x00, 0x00, 0x00, 0x98,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x7c,
		0x00, 0x00, 0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x1f,
		0x00, 0x00, 0x00, 0x19,
		0x00, 0x00, 0x00, 0x13,
		0x00, 0x00, 0x00, 0x0c,
		0x00, 0x00, 0x00, 0x06,
		0xff, 0xff, 0xff, 0xfa,
		0xff, 0xff, 0xff, 0xf3,
		0xff, 0xff, 0xff, 0xed,
		0xff, 0xff, 0xff, 0xe6,
		0xff, 0xff, 0xff, 0xe0,
		0x00, 0x00, 0x00, 0x1f,
		0xff, 0xff, 0xff, 0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo6BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 6;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7c, 0x00, 0x00, 0x00,
		0x64, 0x00, 0x00, 0x00,
		0x4c, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00,
		0x18, 0x00, 0x00, 0x00,
		0xe8, 0x00, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0xb4, 0x00, 0x00, 0x00,
		0x98, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7c, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 7-Bits
//  1.0 0x0000003f 0x0000007e
//  0.8 0x00000032 0x00000064
//  0.6 0x00000026 0x0000004c
//  0.4 0x00000019 0x00000032
//  0.2 0x0000000d 0x0000001a
// -0.2 0xfffffff3 0xffffffe6
// -0.4 0xffffffe6 0xffffffcc
// -0.6 0xffffffda 0xffffffb4
// -0.8 0xffffffcd 0xffffff9a
// -1.0 0xffffffc0 0xffffff80
//  1.0 0x0000003f 0x0000007e
// -1.0 0xffffffc0 0xffffff80
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleIn8BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f,
		0x32,
		0x26,
		0x19,
		0x0d,
		0xf3,
		0xe6,
		0xda,
		0xcd,
		0xc0,
		0x3f,
		0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleIn8BitsUnsignedLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f,
		0x72,
		0x66,
		0x59,
		0x4d,
		0x33,
		0x26,
		0x1a,
		0x0d,
		0x00,
		0x7f,
		0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleIn8BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7e,
		0x64,
		0x4c,
		0x32,
		0x1a,
		0xe6,
		0xcc,
		0xb4,
		0x9a,
		0x80,
		0x7e,
		0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleIn8BitsUnsignedMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe,
		0xe4,
		0xcc,
		0xb2,
		0x9a,
		0x66,
		0x4c,
		0x34,
		0x1a,
		0x00,
		0xfe,
		0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0x00,
		0x32, 0x00,
		0x26, 0x00,
		0x19, 0x00,
		0x0d, 0x00,
		0xf3, 0xff,
		0xe6, 0xff,
		0xda, 0xff,
		0xcd, 0xff,
		0xc0, 0xff,
		0x3f, 0x00,
		0xc0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7e,
		0x00, 0x64,
		0x00, 0x4c,
		0x00, 0x32,
		0x00, 0x1a,
		0x00, 0xe6,
		0x00, 0xcc,
		0x00, 0xb4,
		0x00, 0x9a,
		0x00, 0x80,
		0x00, 0x7e,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x3f,
		0x00, 0x32,
		0x00, 0x26,
		0x00, 0x19,
		0x00, 0x0d,
		0xff, 0xf3,
		0xff, 0xe6,
		0xff, 0xda,
		0xff, 0xcd,
		0xff, 0xc0,
		0x00, 0x3f,
		0xff, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7e, 0x00,
		0x64, 0x00,
		0x4c, 0x00,
		0x32, 0x00,
		0x1a, 0x00,
		0xe6, 0x00,
		0xcc, 0x00,
		0xb4, 0x00,
		0x9a, 0x00,
		0x80, 0x00,
		0x7e, 0x00,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0x00, 0x00,
		0x32, 0x00, 0x00,
		0x26, 0x00, 0x00,
		0x19, 0x00, 0x00,
		0x0d, 0x00, 0x00,
		0xf3, 0xff, 0xff,
		0xe6, 0xff, 0xff,
		0xda, 0xff, 0xff,
		0xcd, 0xff, 0xff,
		0xc0, 0xff, 0xff,
		0x3f, 0x00, 0x00,
		0xc0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x7e,
		0x00, 0x00, 0x64,
		0x00, 0x00, 0x4c,
		0x00, 0x00, 0x32,
		0x00, 0x00, 0x1a,
		0x00, 0x00, 0xe6,
		0x00, 0x00, 0xcc,
		0x00, 0x00, 0xb4,
		0x00, 0x00, 0x9a,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x7e,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x3f,
		0x00, 0x00, 0x32,
		0x00, 0x00, 0x26,
		0x00, 0x00, 0x19,
		0x00, 0x00, 0x0d,
		0xff, 0xff, 0xf3,
		0xff, 0xff, 0xe6,
		0xff, 0xff, 0xda,
		0xff, 0xff, 0xcd,
		0xff, 0xff, 0xc0,
		0x00, 0x00, 0x3f,
		0xff, 0xff, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7e, 0x00, 0x00,
		0x64, 0x00, 0x00,
		0x4c, 0x00, 0x00,
		0x32, 0x00, 0x00,
		0x1a, 0x00, 0x00,
		0xe6, 0x00, 0x00,
		0xcc, 0x00, 0x00,
		0xb4, 0x00, 0x00,
		0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x7e, 0x00, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x00, 0x00,
		0x26, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x00, 0x00,
		0xf3, 0xff, 0xff, 0xff,
		0xe6, 0xff, 0xff, 0xff,
		0xda, 0xff, 0xff, 0xff,
		0xcd, 0xff, 0xff, 0xff,
		0xc0, 0xff, 0xff, 0xff,
		0x3f, 0x00, 0x00, 0x00,
		0xc0, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7e,
		0x00, 0x00, 0x00, 0x64,
		0x00, 0x00, 0x00, 0x4c,
		0x00, 0x00, 0x00, 0x32,
		0x00, 0x00, 0x00, 0x1a,
		0x00, 0x00, 0x00, 0xe6,
		0x00, 0x00, 0x00, 0xcc,
		0x00, 0x00, 0x00, 0xb4,
		0x00, 0x00, 0x00, 0x9a,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x7e,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x3f,
		0x00, 0x00, 0x00, 0x32,
		0x00, 0x00, 0x00, 0x26,
		0x00, 0x00, 0x00, 0x19,
		0x00, 0x00, 0x00, 0x0d,
		0xff, 0xff, 0xff, 0xf3,
		0xff, 0xff, 0xff, 0xe6,
		0xff, 0xff, 0xff, 0xda,
		0xff, 0xff, 0xff, 0xcd,
		0xff, 0xff, 0xff, 0xc0,
		0x00, 0x00, 0x00, 0x3f,
		0xff, 0xff, 0xff, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo7BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7e, 0x00, 0x00, 0x00,
		0x64, 0x00, 0x00, 0x00,
		0x4c, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0xb4, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7e, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 8-Bits
//  1.0 0x0000007f 0x000007f0
//  0.8 0x00000066 0x00000660
//  0.6 0x0000004c 0x000004c0
//  0.4 0x00000033 0x00000330
//  0.2 0x00000019 0x00000190
// -0.2 0xffffffe6 0xfffffe60
// -0.4 0xffffffcd 0xfffffcd0
// -0.6 0xffffffb3 0xfffffb30
// -0.8 0xffffff9a 0xfffff9a0
// -1.0 0xffffff80 0xfffff800
//  1.0 0x0000007f 0x000007f0
// -1.0 0xffffff80 0xfffff800
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleIn8Bits)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f,
		0x66,
		0x4c,
		0x33,
		0x19,
		0xe6,
		0xcd,
		0xb3,
		0x9a,
		0x80,
		0x7f,
		0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00,
		0x66, 0x00,
		0x4c, 0x00,
		0x33, 0x00,
		0x19, 0x00,
		0xe6, 0xff,
		0xcd, 0xff,
		0xb3, 0xff,
		0x9a, 0xff,
		0x80, 0xff,
		0x7f, 0x00,
		0x80, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7f,
		0x00, 0x66,
		0x00, 0x4c,
		0x00, 0x33,
		0x00, 0x19,
		0x00, 0xe6,
		0x00, 0xcd,
		0x00, 0xb3,
		0x00, 0x9a,
		0x00, 0x80,
		0x00, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7f,
		0x00, 0x66,
		0x00, 0x4c,
		0x00, 0x33,
		0x00, 0x19,
		0xff, 0xe6,
		0xff, 0xcd,
		0xff, 0xb3,
		0xff, 0x9a,
		0xff, 0x80,
		0x00, 0x7f,
		0xff, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00,
		0x66, 0x00,
		0x4c, 0x00,
		0x33, 0x00,
		0x19, 0x00,
		0xe6, 0x00,
		0xcd, 0x00,
		0xb3, 0x00,
		0x9a, 0x00,
		0x80, 0x00,
		0x7f, 0x00,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00,
		0x66, 0x00, 0x00,
		0x4c, 0x00, 0x00,
		0x33, 0x00, 0x00,
		0x19, 0x00, 0x00,
		0xe6, 0xff, 0xff,
		0xcd, 0xff, 0xff,
		0xb3, 0xff, 0xff,
		0x9a, 0xff, 0xff,
		0x80, 0xff, 0xff,
		0x7f, 0x00, 0x00,
		0x80, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f,
		0x00, 0x00, 0x66,
		0x00, 0x00, 0x4c,
		0x00, 0x00, 0x33,
		0x00, 0x00, 0x19,
		0x00, 0x00, 0xe6,
		0x00, 0x00, 0xcd,
		0x00, 0x00, 0xb3,
		0x00, 0x00, 0x9a,
		0x00, 0x00, 0x80,
		0x00, 0x00, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f,
		0x00, 0x00, 0x66,
		0x00, 0x00, 0x4c,
		0x00, 0x00, 0x33,
		0x00, 0x00, 0x19,
		0xff, 0xff, 0xe6,
		0xff, 0xff, 0xcd,
		0xff, 0xff, 0xb3,
		0xff, 0xff, 0x9a,
		0xff, 0xff, 0x80,
		0x00, 0x00, 0x7f,
		0xff, 0xff, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00,
		0x66, 0x00, 0x00,
		0x4c, 0x00, 0x00,
		0x33, 0x00, 0x00,
		0x19, 0x00, 0x00,
		0xe6, 0x00, 0x00,
		0xcd, 0x00, 0x00,
		0xb3, 0x00, 0x00,
		0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0x00, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4c, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00,
		0xe6, 0xff, 0xff, 0xff,
		0xcd, 0xff, 0xff, 0xff,
		0xb3, 0xff, 0xff, 0xff,
		0x9a, 0xff, 0xff, 0xff,
		0x80, 0xff, 0xff, 0xff,
		0x7f, 0x00, 0x00, 0x00,
		0x80, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7f,
		0x00, 0x00, 0x00, 0x66,
		0x00, 0x00, 0x00, 0x4c,
		0x00, 0x00, 0x00, 0x33,
		0x00, 0x00, 0x00, 0x19,
		0x00, 0x00, 0x00, 0xe6,
		0x00, 0x00, 0x00, 0xcd,
		0x00, 0x00, 0x00, 0xb3,
		0x00, 0x00, 0x00, 0x9a,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x00, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7f,
		0x00, 0x00, 0x00, 0x66,
		0x00, 0x00, 0x00, 0x4c,
		0x00, 0x00, 0x00, 0x33,
		0x00, 0x00, 0x00, 0x19,
		0xff, 0xff, 0xff, 0xe6,
		0xff, 0xff, 0xff, 0xcd,
		0xff, 0xff, 0xff, 0xb3,
		0xff, 0xff, 0xff, 0x9a,
		0xff, 0xff, 0xff, 0x80,
		0x00, 0x00, 0x00, 0x7f,
		0xff, 0xff, 0xff, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo8BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4c, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x19, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 9-Bits
//  1.0 0x000000ff 0x000007f8
//  0.8 0x000000cc 0x00000660
//  0.6 0x00000099 0x000004c8
//  0.4 0x00000066 0x00000330
//  0.2 0x00000033 0x00000198
// -0.2 0xffffffcd 0xfffffe68
// -0.4 0xffffff9a 0xfffffcd0
// -0.6 0xffffff66 0xfffffb30
// -0.8 0xffffff33 0xfffff998
// -1.0 0xffffff00 0xfffff800
//  1.0 0x000000ff 0x000007f8
// -1.0 0xffffff00 0xfffff800
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x00,
		0xcc, 0x00,
		0x99, 0x00,
		0x66, 0x00,
		0x33, 0x00,
		0xcd, 0xff,
		0x9a, 0xff,
		0x66, 0xff,
		0x33, 0xff,
		0x00, 0xff,
		0xff, 0x00,
		0x00, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x80, 0x7f,
		0x00, 0x66,
		0x80, 0x4c,
		0x00, 0x33,
		0x80, 0x19,
		0x80, 0xe6,
		0x00, 0xcd,
		0x00, 0xb3,
		0x80, 0x99,
		0x00, 0x80,
		0x80, 0x7f,
		0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xff,
		0x00, 0xcc,
		0x00, 0x99,
		0x00, 0x66,
		0x00, 0x33,
		0xff, 0xcd,
		0xff, 0x9a,
		0xff, 0x66,
		0xff, 0x33,
		0xff, 0x00,
		0x00, 0xff,
		0xff, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0x80,
		0x66, 0x00,
		0x4c, 0x80,
		0x33, 0x00,
		0x19, 0x80,
		0xe6, 0x80,
		0xcd, 0x00,
		0xb3, 0x00,
		0x99, 0x80,
		0x80, 0x00,
		0x7f, 0x80,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x00, 0x00,
		0xcc, 0x00, 0x00,
		0x99, 0x00, 0x00,
		0x66, 0x00, 0x00,
		0x33, 0x00, 0x00,
		0xcd, 0xff, 0xff,
		0x9a, 0xff, 0xff,
		0x66, 0xff, 0xff,
		0x33, 0xff, 0xff,
		0x00, 0xff, 0xff,
		0xff, 0x00, 0x00,
		0x00, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x80, 0x7f,
		0x00, 0x00, 0x66,
		0x00, 0x80, 0x4c,
		0x00, 0x00, 0x33,
		0x00, 0x80, 0x19,
		0x00, 0x80, 0xe6,
		0x00, 0x00, 0xcd,
		0x00, 0x00, 0xb3,
		0x00, 0x80, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0x80, 0x7f,
		0x00, 0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xff,
		0x00, 0x00, 0xcc,
		0x00, 0x00, 0x99,
		0x00, 0x00, 0x66,
		0x00, 0x00, 0x33,
		0xff, 0xff, 0xcd,
		0xff, 0xff, 0x9a,
		0xff, 0xff, 0x66,
		0xff, 0xff, 0x33,
		0xff, 0xff, 0x00,
		0x00, 0x00, 0xff,
		0xff, 0xff, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f,0x80,0x00,
		0x66,0x00,0x00,
		0x4c,0x80,0x00,
		0x33,0x00,0x00,
		0x19,0x80,0x00,
		0xe6,0x80,0x00,
		0xcd,0x00,0x00,
		0xb3,0x00,0x00,
		0x99,0x80,0x00,
		0x80,0x00,0x00,
		0x7f,0x80,0x00,
		0x80,0x00,0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0x99, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0xcd, 0xff, 0xff, 0xff,
		0x9a, 0xff, 0xff, 0xff,
		0x66, 0xff, 0xff, 0xff,
		0x33, 0xff, 0xff, 0xff,
		0x00, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x80, 0x7f,
		0x00, 0x00, 0x00, 0x66,
		0x00, 0x00, 0x80, 0x4c,
		0x00, 0x00, 0x00, 0x33,
		0x00, 0x00, 0x80, 0x19,
		0x00, 0x00, 0x80, 0xe6,
		0x00, 0x00, 0x00, 0xcd,
		0x00, 0x00, 0x00, 0xb3,
		0x00, 0x00, 0x80, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0x80, 0x7f,
		0x00, 0x00, 0x00, 0x80,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0xff,
		0x00, 0x00, 0x00, 0xcc,
		0x00, 0x00, 0x00, 0x99,
		0x00, 0x00, 0x00, 0x66,
		0x00, 0x00, 0x00, 0x33,
		0xff, 0xff, 0xff, 0xcd,
		0xff, 0xff, 0xff, 0x9a,
		0xff, 0xff, 0xff, 0x66,
		0xff, 0xff, 0xff, 0x33,
		0xff, 0xff, 0xff, 0x00,
		0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo9BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 9;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f,0x80,0x00,0x00,
		0x66,0x00,0x00,0x00,
		0x4c,0x80,0x00,0x00,
		0x33,0x00,0x00,0x00,
		0x19,0x80,0x00,0x00,
		0xe6,0x80,0x00,0x00,
		0xcd,0x00,0x00,0x00,
		0xb3,0x00,0x00,0x00,
		0x99,0x80,0x00,0x00,
		0x80,0x00,0x00,0x00,
		0x7f,0x80,0x00,0x00,
		0x80,0x00,0x00,0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 10-Bits
//  1.0 0x000001ff 0x000007fc
//  0.8 0x00000199 0x00000664
//  0.6 0x00000133 0x000004cc
//  0.4 0x000000cc 0x00000330
//  0.2 0x00000066 0x00000198
// -0.2 0xffffff9a 0xfffffe68
// -0.4 0xffffff33 0xfffffccc
// -0.6 0xfffffecd 0xfffffb34
// -0.8 0xfffffe66 0xfffff998
// -1.0 0xfffffe00 0xfffff800
//  1.0 0x000001ff 0x000007fc
// -1.0 0xfffffe00 0xfffff800
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x01,
		0x99, 0x01,
		0x33, 0x01,
		0xcc, 0x00,
		0x66, 0x00,
		0x9a, 0xff,
		0x33, 0xff,
		0xcd, 0xfe,
		0x66, 0xfe,
		0x00, 0xfe,
		0xff, 0x01,
		0x00, 0xfe
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xc0, 0x7f,
		0x40, 0x66,
		0xc0, 0x4c,
		0x00, 0x33,
		0x80, 0x19,
		0x80, 0xe6,
		0xc0, 0xcc,
		0x40, 0xb3,
		0x80, 0x99,
		0x00, 0x80,
		0xc0, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x01, 0xff,
		0x01, 0x99,
		0x01, 0x33,
		0x00, 0xcc,
		0x00, 0x66,
		0xff, 0x9a,
		0xff, 0x33,
		0xfe, 0xcd,
		0xfe, 0x66,
		0xfe, 0x00,
		0x01, 0xff,
		0xfe, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xc0,
		0x66, 0x40,
		0x4c, 0xc0,
		0x33, 0x00,
		0x19, 0x80,
		0xe6, 0x80,
		0xcc, 0xc0,
		0xb3, 0x40,
		0x99, 0x80,
		0x80, 0x00,
		0x7f, 0xc0,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x01, 0x00,
		0x99, 0x01, 0x00,
		0x33, 0x01, 0x00,
		0xcc, 0x00, 0x00,
		0x66, 0x00, 0x00,
		0x9a, 0xff, 0xff,
		0x33, 0xff, 0xff,
		0xcd, 0xfe, 0xff,
		0x66, 0xfe, 0xff,
		0x00, 0xfe, 0xff,
		0xff, 0x01, 0x00,
		0x00, 0xfe, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xc0, 0x7f,
		0x00, 0x40, 0x66,
		0x00, 0xc0, 0x4c,
		0x00, 0x00, 0x33,
		0x00, 0x80, 0x19,
		0x00, 0x80, 0xe6,
		0x00, 0xc0, 0xcc,
		0x00, 0x40, 0xb3,
		0x00, 0x80, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xc0, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x01, 0xff,
		0x00, 0x01, 0x99,
		0x00, 0x01, 0x33,
		0x00, 0x00, 0xcc,
		0x00, 0x00, 0x66,
		0xff, 0xff, 0x9a,
		0xff, 0xff, 0x33,
		0xff, 0xfe, 0xcd,
		0xff, 0xfe, 0x66,
		0xff, 0xfe, 0x00,
		0x00, 0x01, 0xff,
		0xff, 0xfe, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xc0, 0x00,
		0x66, 0x40, 0x00,
		0x4c, 0xc0, 0x00,
		0x33, 0x00, 0x00,
		0x19, 0x80, 0x00,
		0xe6, 0x80, 0x00,
		0xcc, 0xc0, 0x00,
		0xb3, 0x40, 0x00,
		0x99, 0x80, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xc0, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x01, 0x00, 0x00,
		0x99, 0x01, 0x00, 0x00,
		0x33, 0x01, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x9a, 0xff, 0xff, 0xff,
		0x33, 0xff, 0xff, 0xff,
		0xcd, 0xfe, 0xff, 0xff,
		0x66, 0xfe, 0xff, 0xff,
		0x00, 0xfe, 0xff, 0xff,
		0xff, 0x01, 0x00, 0x00,
		0x00, 0xfe, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xc0, 0x7f,
		0x00, 0x00, 0x40, 0x66,
		0x00, 0x00, 0xc0, 0x4c,
		0x00, 0x00, 0x00, 0x33,
		0x00, 0x00, 0x80, 0x19,
		0x00, 0x00, 0x80, 0xe6,
		0x00, 0x00, 0xc0, 0xcc,
		0x00, 0x00, 0x40, 0xb3,
		0x00, 0x00, 0x80, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xc0, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x01, 0xff,
		0x00, 0x00, 0x01, 0x99,
		0x00, 0x00, 0x01, 0x33,
		0x00, 0x00, 0x00, 0xcc,
		0x00, 0x00, 0x00, 0x66,
		0xff, 0xff, 0xff, 0x9a,
		0xff, 0xff, 0xff, 0x33,
		0xff, 0xff, 0xfe, 0xcd,
		0xff, 0xff, 0xfe, 0x66,
		0xff, 0xff, 0xfe, 0x00,
		0x00, 0x00, 0x01, 0xff,
		0xff, 0xff, 0xfe, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo10BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 10;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xc0, 0x00, 0x00,
		0x66, 0x40, 0x00, 0x00,
		0x4c, 0xc0, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x19, 0x80, 0x00, 0x00,
		0xe6, 0x80, 0x00, 0x00,
		0xcc, 0xc0, 0x00, 0x00,
		0xb3, 0x40, 0x00, 0x00,
		0x99, 0x80, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xc0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 11-Bits
//  1.0 0x000003ff 0x000007fe
//  0.8 0x00000332 0x00000664
//  0.6 0x00000266 0x000004cc
//  0.4 0x00000199 0x00000332
//  0.2 0x000000cd 0x0000019a
// -0.2 0xffffff33 0xfffffe66
// -0.4 0xfffffe66 0xfffffccc
// -0.6 0xfffffd9a 0xfffffb34
// -0.8 0xfffffccd 0xfffff99a
// -1.0 0xfffffc00 0xfffff800
//  1.0 0x000003ff 0x000007fe
// -1.0 0xfffffc00 0xfffff800
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x03,
		0x32, 0x03,
		0x66, 0x02,
		0x99, 0x01,
		0xcd, 0x00,
		0x33, 0xff,
		0x66, 0xfe,
		0x9a, 0xfd,
		0xcd, 0xfc,
		0x00, 0xfc,
		0xff, 0x03,
		0x00, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xe0, 0x7f,
		0x40, 0x66,
		0xc0, 0x4c,
		0x20, 0x33,
		0xa0, 0x19,
        0x60, 0xe6,
		0xc0, 0xcc,
		0x40, 0xb3,
		0xa0, 0x99,
		0x00, 0x80,
		0xe0, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0xff,
		0x03, 0x32,
		0x02, 0x66,
		0x01, 0x99,
		0x00, 0xcd,
		0xff, 0x33,
		0xfe, 0x66,
		0xfd, 0x9a,
		0xfc, 0xcd,
		0xfc, 0x00,
		0x03, 0xff,
		0xfc, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xe0,
		0x66, 0x40,
		0x4c, 0xc0,
		0x33, 0x20,
		0x19, 0xa0,
		0xe6, 0x60,
		0xcc, 0xc0,
		0xb3, 0x40,
		0x99, 0xa0,
		0x80, 0x00,
		0x7f, 0xe0,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x03, 0x00,
		0x32, 0x03, 0x00,
		0x66, 0x02, 0x00,
		0x99, 0x01, 0x00,
		0xcd, 0x00, 0x00,
		0x33, 0xff, 0xff,
		0x66, 0xfe, 0xff,
		0x9a, 0xfd, 0xff,
		0xcd, 0xfc, 0xff,
		0x00, 0xfc, 0xff,
		0xff, 0x03, 0x00,
		0x00, 0xfc, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xe0, 0x7f,
		0x00, 0x40, 0x66,
		0x00, 0xc0, 0x4c,
		0x00, 0x20, 0x33,
		0x00, 0xa0, 0x19,
        0x00, 0x60, 0xe6,
		0x00, 0xc0, 0xcc,
		0x00, 0x40, 0xb3,
		0x00, 0xa0, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xe0, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x03, 0xff,
		0x00, 0x03, 0x32,
		0x00, 0x02, 0x66,
		0x00, 0x01, 0x99,
		0x00, 0x00, 0xcd,
		0xff, 0xff, 0x33,
		0xff, 0xfe, 0x66,
		0xff, 0xfd, 0x9a,
		0xff, 0xfc, 0xcd,
		0xff, 0xfc, 0x00,
		0x00, 0x03, 0xff,
		0xff, 0xfc, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xe0, 0x00,
		0x66, 0x40, 0x00,
		0x4c, 0xc0, 0x00,
		0x33, 0x20, 0x00,
		0x19, 0xa0, 0x00,
		0xe6, 0x60, 0x00,
		0xcc, 0xc0, 0x00,
		0xb3, 0x40, 0x00,
		0x99, 0xa0, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xe0, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x03, 0x00, 0x00,
		0x32, 0x03, 0x00, 0x00,
		0x66, 0x02, 0x00, 0x00,
		0x99, 0x01, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00,
		0x33, 0xff, 0xff, 0xff,
		0x66, 0xfe, 0xff, 0xff,
		0x9a, 0xfd, 0xff, 0xff,
		0xcd, 0xfc, 0xff, 0xff,
		0x00, 0xfc, 0xff, 0xff,
		0xff, 0x03, 0x00, 0x00,
		0x00, 0xfc, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xe0, 0x7f,
		0x00, 0x00, 0x40, 0x66,
		0x00, 0x00, 0xc0, 0x4c,
		0x00, 0x00, 0x20, 0x33,
		0x00, 0x00, 0xa0, 0x19,
        0x00, 0x00, 0x60, 0xe6,
		0x00, 0x00, 0xc0, 0xcc,
		0x00, 0x00, 0x40, 0xb3,
		0x00, 0x00, 0xa0, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xe0, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x03, 0xff,
		0x00, 0x00, 0x03, 0x32,
		0x00, 0x00, 0x02, 0x66,
		0x00, 0x00, 0x01, 0x99,
		0x00, 0x00, 0x00, 0xcd,
		0xff, 0xff, 0xff, 0x33,
		0xff, 0xff, 0xfe, 0x66,
		0xff, 0xff, 0xfd, 0x9a,
		0xff, 0xff, 0xfc, 0xcd,
		0xff, 0xff, 0xfc, 0x00,
		0x00, 0x00, 0x03, 0xff,
		0xff, 0xff, 0xfc, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo11BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 11;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xe0, 0x00, 0x00,
		0x66, 0x40, 0x00, 0x00,
		0x4c, 0xc0, 0x00, 0x00,
		0x33, 0x20, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00,
		0xcc, 0xc0, 0x00, 0x00,
		0xb3, 0x40, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xe0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 12-Bits
//  1.0 0x000007ff 0x00007ff0
//  0.8 0x00000666 0x00006660
//  0.6 0x000004cc 0x00004cc0
//  0.4 0x00000333 0x00003330
//  0.2 0x00000199 0x00001990
// -0.2 0xfffffe66 0xffffe660
// -0.4 0xfffffccd 0xffffccd0
// -0.6 0xfffffb33 0xffffb330
// -0.8 0xfffff99a 0xffff99a0
// -1.0 0xfffff800 0xffff8000
//  1.0 0x000007ff 0x00007ff0
// -1.0 0xfffff800 0xffff8000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x07,
		0x66, 0x06,
		0xcc, 0x04,
		0x33, 0x03,
		0x99, 0x01,
		0x66, 0xfe,
		0xcd, 0xfc,
		0x33, 0xfb,
		0x9a, 0xf9,
		0x00, 0xf8,
		0xff, 0x07,
		0x00, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf0, 0x7f,
		0x60, 0x66,
		0xc0, 0x4c,
		0x30, 0x33,
		0x90, 0x19,
		0x60, 0xe6,
		0xd0, 0xcc,
		0x30, 0xb3,
		0xa0, 0x99,
		0x00, 0x80,
		0xf0, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0xff,
		0x06, 0x66,
		0x04, 0xcc,
		0x03, 0x33,
		0x01, 0x99,
		0xfe, 0x66,
		0xfc, 0xcd,
		0xfb, 0x33,
		0xf9, 0x9a,
		0xf8, 0x00,
		0x07, 0xff,
		0xf8, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf0,
		0x66, 0x60,
		0x4c, 0xc0,
		0x33, 0x30,
		0x19, 0x90,
		0xe6, 0x60,
		0xcc, 0xd0,
		0xb3, 0x30,
		0x99, 0xa0,
		0x80, 0x00,
		0x7f, 0xf0,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x07, 0x00,
		0x66, 0x06, 0x00,
		0xcc, 0x04, 0x00,
		0x33, 0x03, 0x00,
		0x99, 0x01, 0x00,
		0x66, 0xfe, 0xff,
		0xcd, 0xfc, 0xff,
		0x33, 0xfb, 0xff,
		0x9a, 0xf9, 0xff,
		0x00, 0xf8, 0xff,
		0xff, 0x07, 0x00,
		0x00, 0xf8, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xf0, 0x7f,
		0x00, 0x60, 0x66,
		0x00, 0xc0, 0x4c,
		0x00, 0x30, 0x33,
		0x00, 0x90, 0x19,
		0x00, 0x60, 0xe6,
		0x00, 0xd0, 0xcc,
		0x00, 0x30, 0xb3,
		0x00, 0xa0, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xf0, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x07, 0xff,
		0x00, 0x06, 0x66,
		0x00, 0x04, 0xcc,
		0x00, 0x03, 0x33,
		0x00, 0x01, 0x99,
		0xff, 0xfe, 0x66,
		0xff, 0xfc, 0xcd,
		0xff, 0xfb, 0x33,
		0xff, 0xf9, 0x9a,
		0xff, 0xf8, 0x00,
		0x00, 0x07, 0xff,
		0xff, 0xf8, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf0, 0x00,
		0x66, 0x60, 0x00,
		0x4c, 0xc0, 0x00,
		0x33, 0x30, 0x00,
		0x19, 0x90, 0x00,
		0xe6, 0x60, 0x00,
		0xcc, 0xd0, 0x00,
		0xb3, 0x30, 0x00,
		0x99, 0xa0, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xf0, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x07, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00,
		0xcc, 0x04, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00,
		0x99, 0x01, 0x00, 0x00,
		0x66, 0xfe, 0xff, 0xff,
		0xcd, 0xfc, 0xff, 0xff,
		0x33, 0xfb, 0xff, 0xff,
		0x9a, 0xf9, 0xff, 0xff,
		0x00, 0xf8, 0xff, 0xff,
		0xff, 0x07, 0x00, 0x00,
		0x00, 0xf8, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xf0, 0x7f,
		0x00, 0x00, 0x60, 0x66,
		0x00, 0x00, 0xc0, 0x4c,
		0x00, 0x00, 0x30, 0x33,
		0x00, 0x00, 0x90, 0x19,
		0x00, 0x00, 0x60, 0xe6,
		0x00, 0x00, 0xd0, 0xcc,
		0x00, 0x00, 0x30, 0xb3,
		0x00, 0x00, 0xa0, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xf0, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x07, 0xff,
		0x00, 0x00, 0x06, 0x66,
		0x00, 0x00, 0x04, 0xcc,
		0x00, 0x00, 0x03, 0x33,
		0x00, 0x00, 0x01, 0x99,
		0xff, 0xff, 0xfe, 0x66,
		0xff, 0xff, 0xfc, 0xcd,
		0xff, 0xff, 0xfb, 0x33,
		0xff, 0xff, 0xf9, 0x9a,
		0xff, 0xff, 0xf8, 0x00,
		0x00, 0x00, 0x07, 0xff,
		0xff, 0xff, 0xf8, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo12BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf0, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00,
		0x4c, 0xc0, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00,
		0x19, 0x90, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xf0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 13-Bits
//  1.0 0x00000fff 0x00007ff8
//  0.8 0x00000ccc 0x00006660
//  0.6 0x00000999 0x00004cc8
//  0.4 0x00000666 0x00003330
//  0.2 0x00000333 0x00001998
// -0.2 0xfffffccd 0xffffe668
// -0.4 0xfffff99a 0xffffccd0
// -0.6 0xfffff666 0xffffb330
// -0.8 0xfffff333 0xffff9998
// -1.0 0xfffff000 0xffff8000
//  1.0 0x00000fff 0x00007ff8
// -1.0 0xfffff000 0xffff8000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x0f,
		0xcc, 0x0c,
		0x99, 0x09,
		0x66, 0x06,
		0x33, 0x03,
		0xcd, 0xfc,
		0x9a, 0xf9,
		0x66, 0xf6,
		0x33, 0xf3,
		0x00, 0xf0,
		0xff, 0x0f,
		0x00, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf8, 0x7f,
		0x60, 0x66,
		0xc8, 0x4c,
		0x30, 0x33,
		0x98, 0x19,
		0x68, 0xe6,
		0xd0, 0xcc,
		0x30, 0xb3,
		0x98, 0x99,
		0x00, 0x80,
		0xf8, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0xff,
		0x0c, 0xcc,
		0x09, 0x99,
		0x06, 0x66,
		0x03, 0x33,
		0xfc, 0xcd,
		0xf9, 0x9a,
		0xf6, 0x66,
		0xf3, 0x33,
		0xf0, 0x00,
		0x0f, 0xff,
		0xf0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf8,
		0x66, 0x60,
		0x4c, 0xc8,
		0x33, 0x30,
		0x19, 0x98,
		0xe6, 0x68,
		0xcc, 0xd0,
		0xb3, 0x30,
		0x99, 0x98,
		0x80, 0x00,
		0x7f, 0xf8,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x0f, 0x00,
		0xcc, 0x0c, 0x00,
		0x99, 0x09, 0x00,
		0x66, 0x06, 0x00,
		0x33, 0x03, 0x00,
		0xcd, 0xfc, 0xff,
		0x9a, 0xf9, 0xff,
		0x66, 0xf6, 0xff,
		0x33, 0xf3, 0xff,
		0x00, 0xf0, 0xff,
		0xff, 0x0f, 0x00,
		0x00, 0xf0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xf8, 0x7f,
		0x00, 0x60, 0x66,
		0x00, 0xc8, 0x4c,
		0x00, 0x30, 0x33,
		0x00, 0x98, 0x19,
		0x00, 0x68, 0xe6,
		0x00, 0xd0, 0xcc,
		0x00, 0x30, 0xb3,
		0x00, 0x98, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xf8, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x0f, 0xff,
		0x00, 0x0c, 0xcc,
		0x00, 0x09, 0x99,
		0x00, 0x06, 0x66,
		0x00, 0x03, 0x33,
		0xff, 0xfc, 0xcd,
		0xff, 0xf9, 0x9a,
		0xff, 0xf6, 0x66,
		0xff, 0xf3, 0x33,
		0xff, 0xf0, 0x00,
		0x00, 0x0f, 0xff,
		0xff, 0xf0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf8, 0x00,
		0x66, 0x60, 0x00,
		0x4c, 0xc8, 0x00,
		0x33, 0x30, 0x00,
		0x19, 0x98, 0x00,
		0xe6, 0x68, 0x00,
		0xcc, 0xd0, 0x00,
		0xb3, 0x30, 0x00,
		0x99, 0x98, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xf8, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x0f, 0x00, 0x00,
		0xcc, 0x0c, 0x00, 0x00,
		0x99, 0x09, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00,
		0xcd, 0xfc, 0xff, 0xff,
		0x9a, 0xf9, 0xff, 0xff,
		0x66, 0xf6, 0xff, 0xff,
		0x33, 0xf3, 0xff, 0xff,
		0x00, 0xf0, 0xff, 0xff,
		0xff, 0x0f, 0x00, 0x00,
		0x00, 0xf0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xf8, 0x7f,
		0x00, 0x00, 0x60, 0x66,
		0x00, 0x00, 0xc8, 0x4c,
		0x00, 0x00, 0x30, 0x33,
		0x00, 0x00, 0x98, 0x19,
		0x00, 0x00, 0x68, 0xe6,
		0x00, 0x00, 0xd0, 0xcc,
		0x00, 0x00, 0x30, 0xb3,
		0x00, 0x00, 0x98, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xf8, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x0f, 0xff,
		0x00, 0x00, 0x0c, 0xcc,
		0x00, 0x00, 0x09, 0x99,
		0x00, 0x00, 0x06, 0x66,
		0x00, 0x00, 0x03, 0x33,
		0xff, 0xff, 0xfc, 0xcd,
		0xff, 0xff, 0xf9, 0x9a,
		0xff, 0xff, 0xf6, 0x66,
		0xff, 0xff, 0xf3, 0x33,
		0xff, 0xff, 0xf0, 0x00,
		0x00, 0x00, 0x0f, 0xff,
		0xff, 0xff, 0xf0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo13BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 13;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xf8, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00,
		0x4c, 0xc8, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00,
		0x19, 0x98, 0x00, 0x00,
		0xe6, 0x68, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00,
		0x99, 0x98, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xf8, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 14-Bits
//  1.0 0x00001fff 0x00007ffc
//  0.8 0x00001999 0x00006664
//  0.6 0x00001333 0x00004ccc
//  0.4 0x00000ccc 0x00003330
//  0.2 0x00000666 0x00001998
// -0.2 0xfffff99a 0xffffe668
// -0.4 0xfffff333 0xffffcccc
// -0.6 0xffffeccd 0xffffb334
// -0.8 0xffffe666 0xffff9998
// -1.0 0xffffe000 0xffff8000
//  1.0 0x00001fff 0x00007ffc
// -1.0 0xffffe000 0xffff8000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x1f,
		0x99, 0x19,
		0x33, 0x13,
		0xcc, 0x0c,
		0x66, 0x06,
		0x9a, 0xf9,
		0x33, 0xf3,
		0xcd, 0xec,
		0x66, 0xe6,
		0x00, 0xe0,
		0xff, 0x1f,
		0x00, 0xe0,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfc, 0x7f,
		0x64, 0x66,
		0xcc, 0x4c,
		0x30, 0x33,
		0x98, 0x19,
		0x68, 0xe6,
		0xcc, 0xcc,
		0x34, 0xb3,
		0x98, 0x99,
        0x00, 0x80,
		0xfc, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0xff,
		0x19, 0x99,
		0x13, 0x33,
		0x0c, 0xcc,
		0x06, 0x66,
		0xf9, 0x9a,
		0xf3, 0x33,
		0xec, 0xcd,
		0xe6, 0x66,
		0xe0, 0x00,
		0x1f, 0xff,
		0xe0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfc,
		0x66, 0x64,
		0x4c, 0xcc,
		0x33, 0x30,
		0x19, 0x98,
		0xe6, 0x68,
		0xcc, 0xcc,
		0xb3, 0x34,
		0x99, 0x98,
		0x80, 0x00,
		0x7f, 0xfc,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x1f, 0x00,
		0x99, 0x19, 0x00,
		0x33, 0x13, 0x00,
		0xcc, 0x0c, 0x00,
		0x66, 0x06, 0x00,
		0x9a, 0xf9, 0xff,
		0x33, 0xf3, 0xff,
		0xcd, 0xec, 0xff,
		0x66, 0xe6, 0xff,
		0x00, 0xe0, 0xff,
		0xff, 0x1f, 0x00,
		0x00, 0xe0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xfc, 0x7f,
		0x00, 0x64, 0x66,
		0x00, 0xcc, 0x4c,
		0x00, 0x30, 0x33,
		0x00, 0x98, 0x19,
		0x00, 0x68, 0xe6,
		0x00, 0xcc, 0xcc,
		0x00, 0x34, 0xb3,
		0x00, 0x98, 0x99,
        0x00, 0x00, 0x80,
		0x00, 0xfc, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x1f, 0xff,
		0x00, 0x19, 0x99,
		0x00, 0x13, 0x33,
		0x00, 0x0c, 0xcc,
		0x00, 0x06, 0x66,
		0xff, 0xf9, 0x9a,
		0xff, 0xf3, 0x33,
		0xff, 0xec, 0xcd,
		0xff, 0xe6, 0x66,
		0xff, 0xe0, 0x00,
		0x00, 0x1f, 0xff,
		0xff, 0xe0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfc, 0x00,
		0x66, 0x64, 0x00,
		0x4c, 0xcc, 0x00,
		0x33, 0x30, 0x00,
		0x19, 0x98, 0x00,
		0xe6, 0x68, 0x00,
		0xcc, 0xcc, 0x00,
		0xb3, 0x34, 0x00,
		0x99, 0x98, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xfc, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x1f, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0x33, 0x13, 0x00, 0x00,
		0xcc, 0x0c, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00,
		0x9a, 0xf9, 0xff, 0xff,
		0x33, 0xf3, 0xff, 0xff,
		0xcd, 0xec, 0xff, 0xff,
		0x66, 0xe6, 0xff, 0xff,
		0x00, 0xe0, 0xff, 0xff,
		0xff, 0x1f, 0x00, 0x00,
		0x00, 0xe0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xfc, 0x7f,
		0x00, 0x00, 0x64, 0x66,
		0x00, 0x00, 0xcc, 0x4c,
		0x00, 0x00, 0x30, 0x33,
		0x00, 0x00, 0x98, 0x19,
		0x00, 0x00, 0x68, 0xe6,
		0x00, 0x00, 0xcc, 0xcc,
		0x00, 0x00, 0x34, 0xb3,
		0x00, 0x00, 0x98, 0x99,
        0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xfc, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x1f, 0xff,
		0x00, 0x00, 0x19, 0x99,
		0x00, 0x00, 0x13, 0x33,
		0x00, 0x00, 0x0c, 0xcc,
		0x00, 0x00, 0x06, 0x66,
		0xff, 0xff, 0xf9, 0x9a,
		0xff, 0xff, 0xf3, 0x33,
		0xff, 0xff, 0xec, 0xcd,
		0xff, 0xff, 0xe6, 0x66,
		0xff, 0xff, 0xe0, 0x00,
		0x00, 0x00, 0x1f, 0xff,
		0xff, 0xff, 0xe0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo14BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 14;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfc, 0x00, 0x00,
		0x66, 0x64, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00,
		0x19, 0x98, 0x00, 0x00,
		0xe6, 0x68, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0xb3, 0x34, 0x00, 0x00,
		0x99, 0x98, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xfc, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 15-Bits
//  1.0 0x00003fff 0x00007ffe
//  0.8 0x00003332 0x00006664
//  0.6 0x00002666 0x00004ccc
//  0.4 0x00001999 0x00003332
//  0.2 0x00000ccd 0x0000199a
// -0.2 0xfffff333 0xffffe666
// -0.4 0xffffe666 0xffffcccc
// -0.6 0xffffd99a 0xffffb334
// -0.8 0xffffcccd 0xffff999a
// -1.0 0xffffc000 0xffff8000
//  1.0 0x00003fff 0x00007ffe
// -1.0 0xffffc000 0xffff8000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian16BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x3f,
		0x32, 0x33,
		0x66, 0x26,
		0x99, 0x19,
		0xcd, 0x0c,
		0x33, 0xf3,
		0x66, 0xe6,
		0x9a, 0xd9,
		0xcd, 0xcc,
		0x00, 0xc0,
		0xff, 0x3f,
		0x00, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian16BitsUnsignedLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x7f,
		0x32, 0x73,
		0x66, 0x66,
		0x99, 0x59,
		0xcd, 0x4c,
		0x33, 0x33,
		0x66, 0x26,
		0x9a, 0x19,
		0xcd, 0x0c,
		0x00, 0x00,
		0xff, 0x7f,
		0x00, 0x00	
    };
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian16BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0x7f,
		0x64, 0x66,
		0xcc, 0x4c,
		0x32, 0x33,
		0x9a, 0x19,
		0x66, 0xe6,
		0xcc, 0xcc,
		0x34, 0xb3,
		0x9a, 0x99,
		0x00, 0x80,
		0xfe, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian16BitsUnsignedMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0xff,
		0x64, 0xe6,
		0xcc, 0xcc,
		0x32, 0xb3,
		0x9a, 0x99,
		0x66, 0x66,
		0xcc, 0x4c,
		0x34, 0x33,
		0x9a, 0x19,
		0x00, 0x00,
		0xfe, 0xff,
		0x00, 0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian16BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0xff,
		0x33, 0x32,
		0x26, 0x66,
		0x19, 0x99,
		0x0c, 0xcd,
		0xf3, 0x33,
		0xe6, 0x66,
		0xd9, 0x9a,
		0xcc, 0xcd,
		0xc0, 0x00,
		0x3f, 0xff,
		0xc0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian16BitsUnsignedLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff,
		0x73, 0x32,
		0x66, 0x66,
		0x59, 0x99,
		0x4c, 0xcd,
		0x33, 0x33,
		0x26, 0x66,
		0x19, 0x9a,
		0x0c, 0xcd,
		0x00, 0x00,
		0x7f, 0xff,
		0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian16BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfe,
		0x66, 0x64,
		0x4c, 0xcc,
		0x33, 0x32,
		0x19, 0x9a,
		0xe6, 0x66,
		0xcc, 0xcc,
		0xb3, 0x34,
		0x99, 0x9a,
		0x80, 0x00,
		0x7f, 0xfe,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian16BitsUnsignedMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xfe,
		0xe6, 0x64,
		0xcc, 0xcc,
		0xb3, 0x32,
		0x99, 0x9a,
		0x66, 0x66,
		0x4c, 0xcc,
		0x33, 0x34,
		0x19, 0x9a,
		0x00, 0x00,
		0xff, 0xfe,
		0x00, 0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x3f, 0x00,
		0x32, 0x33, 0x00,
		0x66, 0x26, 0x00,
		0x99, 0x19, 0x00,
		0xcd, 0x0c, 0x00,
		0x33, 0xf3, 0xff,
		0x66, 0xe6, 0xff,
		0x9a, 0xd9, 0xff,
		0xcd, 0xcc, 0xff,
		0x00, 0xc0, 0xff,
		0xff, 0x3f, 0x00,
		0x00, 0xc0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xfe, 0x7f,
		0x00, 0x64, 0x66,
		0x00, 0xcc, 0x4c,
		0x00, 0x32, 0x33,
		0x00, 0x9a, 0x19,
		0x00, 0x66, 0xe6,
		0x00, 0xcc, 0xcc,
		0x00, 0x34, 0xb3,
		0x00, 0x9a, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xfe, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x3f, 0xff,
		0x00, 0x33, 0x32,
		0x00, 0x26, 0x66,
		0x00, 0x19, 0x99,
		0x00, 0x0c, 0xcd,
		0xff, 0xf3, 0x33,
		0xff, 0xe6, 0x66,
		0xff, 0xd9, 0x9a,
		0xff, 0xcc, 0xcd,
		0xff, 0xc0, 0x00,
		0x00, 0x3f, 0xff,
		0xff, 0xc0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfe, 0x00,
		0x66, 0x64, 0x00,
		0x4c, 0xcc, 0x00,
		0x33, 0x32, 0x00,
		0x19, 0x9a, 0x00,
		0xe6, 0x66, 0x00,
		0xcc, 0xcc, 0x00,
		0xb3, 0x34, 0x00,
		0x99, 0x9a, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xfe, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x3f, 0x00, 0x00,
		0x32, 0x33, 0x00, 0x00,
		0x66, 0x26, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0xcd, 0x0c, 0x00, 0x00,
		0x33, 0xf3, 0xff, 0xff,
		0x66, 0xe6, 0xff, 0xff,
		0x9a, 0xd9, 0xff, 0xff,
		0xcd, 0xcc, 0xff, 0xff,
		0x00, 0xc0, 0xff, 0xff,
		0xff, 0x3f, 0x00, 0x00,
		0x00, 0xc0, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xfe, 0x7f,
		0x00, 0x00, 0x64, 0x66,
		0x00, 0x00, 0xcc, 0x4c,
		0x00, 0x00, 0x32, 0x33,
		0x00, 0x00, 0x9a, 0x19,
		0x00, 0x00, 0x66, 0xe6,
		0x00, 0x00, 0xcc, 0xcc,
		0x00, 0x00, 0x34, 0xb3,
		0x00, 0x00, 0x9a, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xfe, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x3f, 0xff,
		0x00, 0x00, 0x33, 0x32,
		0x00, 0x00, 0x26, 0x66,
		0x00, 0x00, 0x19, 0x99,
		0x00, 0x00, 0x0c, 0xcd,
		0xff, 0xff, 0xf3, 0x33,
		0xff, 0xff, 0xe6, 0x66,
		0xff, 0xff, 0xd9, 0x9a,
		0xff, 0xff, 0xcc, 0xcd,
		0xff, 0xff, 0xc0, 0x00,
		0x00, 0x00, 0x3f, 0xff,
		0xff, 0xff, 0xc0, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo15BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xfe, 0x00, 0x00,
		0x66, 0x64, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00,
		0x33, 0x32, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0xb3, 0x34, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xfe, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 16-Bits
//  1.0 0x00007fff 0x0007fff0
//  0.8 0x00006666 0x00066660
//  0.6 0x00004ccc 0x0004ccc0
//  0.4 0x00003333 0x00033330
//  0.2 0x00001999 0x00019990
// -0.2 0xffffe666 0xfffe6660
// -0.4 0xffffcccd 0xfffcccd0
// -0.6 0xffffb333 0xfffb3330
// -0.8 0xffff999a 0xfff999a0
// -1.0 0xffff8000 0xfff80000
//  1.0 0x00007fff 0x0007fff0
// -1.0 0xffff8000 0xfff80000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndian16Bits)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x7f,
		0x66, 0x66,
		0xcc, 0x4c,
		0x33, 0x33,
		0x99, 0x19,
		0x66, 0xe6,
		0xcd, 0xcc,
		0x33, 0xb3,
		0x9a, 0x99,
		0x00, 0x80,
		0xff, 0x7f,
		0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndianUnsigned16Bits)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff,
		0x66, 0xe6,
		0xcc, 0xcc,
		0x33, 0xb3,
		0x99, 0x99,
		0x66, 0x66,
		0xcd, 0x4c,
		0x33, 0x33,
		0x9a, 0x19,
		0x00, 0x00,
		0xff, 0xff,
		0x00, 0x00
	};
		
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndian16Bits)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff,
		0x66, 0x66,
		0x4c, 0xcc,
		0x33, 0x33,
		0x19, 0x99,
		0xe6, 0x66,
		0xcc, 0xcd,
		0xb3, 0x33,
		0x99, 0x9a,
		0x80, 0x00,
		0x7f, 0xff,
		0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndianUnsigned16Bits)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff,
		0xe6, 0x66,
		0xcc, 0xcc,
		0xb3, 0x33,
		0x99, 0x99,
		0x66, 0x66,
		0x4c, 0xcd,
		0x33, 0x33,
		0x19, 0x9a,
		0x00, 0x00,
		0xff, 0xff,
		0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00,
		0x66, 0x66, 0x00,
		0xcc, 0x4c, 0x00,
		0x33, 0x33, 0x00,
		0x99, 0x19, 0x00,
		0x66, 0xe6, 0xff,
		0xcd, 0xcc, 0xff,
		0x33, 0xb3, 0xff,
		0x9a, 0x99, 0xff,
		0x00, 0x80, 0xff,
		0xff, 0x7f, 0x00,
		0x00, 0x80, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f,
		0x00, 0x66, 0x66,
		0x00, 0xcc, 0x4c,
		0x00, 0x33, 0x33,
		0x00, 0x99, 0x19,
		0x00, 0x66, 0xe6,
		0x00, 0xcd, 0xcc,
		0x00, 0x33, 0xb3,
		0x00, 0x9a, 0x99,
		0x00, 0x00, 0x80,
		0x00, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff,
		0x00, 0x66, 0x66,
		0x00, 0x4c, 0xcc,
		0x00, 0x33, 0x33,
		0x00, 0x19, 0x99,
		0xff, 0xe6, 0x66,
		0xff, 0xcc, 0xcd,
		0xff, 0xb3, 0x33,
		0xff, 0x99, 0x9a,
		0xff, 0x80, 0x00,
		0x00, 0x7f, 0xff,
		0xff, 0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00,
		0x66, 0x66, 0x00,
		0x4c, 0xcc, 0x00,
		0x33, 0x33, 0x00,
		0x19, 0x99, 0x00,
		0xe6, 0x66, 0x00,
		0xcc, 0xcd, 0x00,
		0xb3, 0x33, 0x00,
		0x99, 0x9a, 0x00,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0x00,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0x66, 0xe6, 0xff, 0xff,
		0xcd, 0xcc, 0xff, 0xff,
		0x33, 0xb3, 0xff, 0xff,
		0x9a, 0x99, 0xff, 0xff,
		0x00, 0x80, 0xff, 0xff,
		0xff, 0x7f, 0x00, 0x00,
		0x00, 0x80, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f,
		0x00, 0x00, 0x66, 0x66,
		0x00, 0x00, 0xcc, 0x4c,
		0x00, 0x00, 0x33, 0x33,
		0x00, 0x00, 0x99, 0x19,
		0x00, 0x00, 0x66, 0xe6,
		0x00, 0x00, 0xcd, 0xcc,
		0x00, 0x00, 0x33, 0xb3,
		0x00, 0x00, 0x9a, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x00, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f, 0xff,
		0x00, 0x00, 0x66, 0x66,
		0x00, 0x00, 0x4c, 0xcc,
		0x00, 0x00, 0x33, 0x33,
		0x00, 0x00, 0x19, 0x99,
		0xff, 0xff, 0xe6, 0x66,
		0xff, 0xff, 0xcc, 0xcd,
		0xff, 0xff, 0xb3, 0x33,
		0xff, 0xff, 0x99, 0x9a,
		0xff, 0xff, 0x80, 0x00,
		0x00, 0x00, 0x7f, 0xff,
		0xff, 0xff, 0x80, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo16BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 17-Bits
//  1.0 0x0000ffff 0x0007fff8
//  0.8 0x0000cccc 0x00066660
//  0.6 0x00009999 0x0004ccc8
//  0.4 0x00006666 0x00033330
//  0.2 0x00003333 0x00019998
// -0.2 0xffffcccd 0xfffe6668
// -0.4 0xffff999a 0xfffcccd0
// -0.6 0xffff6666 0xfffb3330
// -0.8 0xffff3333 0xfff99998
// -1.0 0xffff0000 0xfff80000
//  1.0 0x0000ffff 0x0007fff8
// -1.0 0xffff0000 0xfff80000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x00,
		0xcc, 0xcc, 0x00,
		0x99, 0x99, 0x00,
		0x66, 0x66, 0x00,
		0x33, 0x33, 0x00,
		0xcd, 0xcc, 0xff,
		0x9a, 0x99, 0xff,
		0x66, 0x66, 0xff,
		0x33, 0x33, 0xff,
		0x00, 0x00, 0xff,
		0xff, 0xff, 0x00,
		0x00, 0x00, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x80, 0xff, 0x7f,
		0x00, 0x66, 0x66,
		0x80, 0xcc, 0x4c,
		0x00, 0x33, 0x33,
		0x80, 0x99, 0x19,
		0x80, 0x66, 0xe6,
		0x00, 0xcd, 0xcc,
		0x00, 0x33, 0xb3,
		0x80, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0x80, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xff, 0xff,
		0x00, 0xcc, 0xcc,
		0x00, 0x99, 0x99,
		0x00, 0x66, 0x66,
		0x00, 0x33, 0x33,
		0xff, 0xcc, 0xcd,
		0xff, 0x99, 0x9a,
		0xff, 0x66, 0x66,
		0xff, 0x33, 0x33,
		0xff, 0x00, 0x00,
		0x00, 0xff, 0xff,
		0xff, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0x80,
		0x66, 0x66, 0x00,
		0x4c, 0xcc, 0x80,
		0x33, 0x33, 0x00,
		0x19, 0x99, 0x80,
		0xe6, 0x66, 0x80,
		0xcc, 0xcd, 0x00,
		0xb3, 0x33, 0x00,
		0x99, 0x99, 0x80,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0x80,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0xcd, 0xcc, 0xff, 0xff,
		0x9a, 0x99, 0xff, 0xff,
		0x66, 0x66, 0xff, 0xff,
		0x33, 0x33, 0xff, 0xff,
		0x00, 0x00, 0xff, 0xff,
		0xff, 0xff, 0x00, 0x00,
		0x00, 0x00, 0xff, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x80, 0xff, 0x7f,
		0x00, 0x00, 0x66, 0x66,
		0x00, 0x80, 0xcc, 0x4c,
		0x00, 0x00, 0x33, 0x33,
		0x00, 0x80, 0x99, 0x19,
		0x00, 0x80, 0x66, 0xe6,
		0x00, 0x00, 0xcd, 0xcc,
		0x00, 0x00, 0x33, 0xb3,
		0x00, 0x80, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0x80, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff,
		0x00, 0x00, 0xcc, 0xcc,
		0x00, 0x00, 0x99, 0x99,
		0x00, 0x00, 0x66, 0x66,
		0x00, 0x00, 0x33, 0x33,
		0xff, 0xff, 0xcc, 0xcd,
		0xff, 0xff, 0x99, 0x9a,
		0xff, 0xff, 0x66, 0x66,
		0xff, 0xff, 0x33, 0x33,
		0xff, 0xff, 0x00, 0x00,
		0x00, 0x00, 0xff, 0xff,
		0xff, 0xff, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo17BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 17;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0x80, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcc, 0x80, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x99, 0x80, 0x00,
		0xe6, 0x66, 0x80, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x99, 0x80, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0x80, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 18-Bits
//  1.0 0x0001ffff 0x0007fffc
//  0.8 0x00019999 0x00066664
//  0.6 0x00013333 0x0004cccc
//  0.4 0x0000cccc 0x00033330
//  0.2 0x00006666 0x00019998
// -0.2 0xffff999a 0xfffe6668
// -0.4 0xffff3333 0xfffccccc
// -0.6 0xfffecccd 0xfffb3334
// -0.8 0xfffe6666 0xfff99998
// -1.0 0xfffe0000 0xfff80000
//  1.0 0x0001ffff 0x0007fffc
// -1.0 0xfffe0000 0xfff80000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x01,
		0x99, 0x99, 0x01,
		0x33, 0x33, 0x01,
		0xcc, 0xcc, 0x00,
		0x66, 0x66, 0x00,
		0x9a, 0x99, 0xff,
		0x33, 0x33, 0xff,
		0xcd, 0xcc, 0xfe,
		0x66, 0x66, 0xfe,
		0x00, 0x00, 0xfe,
		0xff, 0xff, 0x01,
		0x00, 0x00, 0xfe
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xc0, 0xff, 0x7f,
		0x40, 0x66, 0x66,
		0xc0, 0xcc, 0x4c,
		0x00, 0x33, 0x33,
		0x80, 0x99, 0x19,
		0x80, 0x66, 0xe6,
		0xc0, 0xcc, 0xcc,
		0x40, 0x33, 0xb3,
		0x80, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xc0, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x01, 0xff, 0xff,
		0x01, 0x99, 0x99,
		0x01, 0x33, 0x33,
		0x00, 0xcc, 0xcc,
		0x00, 0x66, 0x66,
		0xff, 0x99, 0x9a,
		0xff, 0x33, 0x33,
		0xfe, 0xcc, 0xcd,
		0xfe, 0x66, 0x66,
		0xfe, 0x00, 0x00,
		0x01, 0xff, 0xff,
		0xfe, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12] = {
        1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
    };
#else
    const sample_t c_sampleInput[12] = {
        1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
    };
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xc0,
		0x66, 0x66, 0x40,
		0x4c, 0xcc, 0xc0,
		0x33, 0x33, 0x00,
		0x19, 0x99, 0x80,
		0xe6, 0x66, 0x80,
		0xcc, 0xcc, 0xc0,
		0xb3, 0x33, 0x40,
		0x99, 0x99, 0x80,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xc0,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x01, 0x00,
		0x99, 0x99, 0x01, 0x00,
		0x33, 0x33, 0x01, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x9a, 0x99, 0xff, 0xff,
		0x33, 0x33, 0xff, 0xff,
		0xcd, 0xcc, 0xfe, 0xff,
		0x66, 0x66, 0xfe, 0xff,
		0x00, 0x00, 0xfe, 0xff,
		0xff, 0xff, 0x01, 0x00,
		0x00, 0x00, 0xfe, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xc0, 0xff, 0x7f,
		0x00, 0x40, 0x66, 0x66,
		0x00, 0xc0, 0xcc, 0x4c,
		0x00, 0x00, 0x33, 0x33,
		0x00, 0x80, 0x99, 0x19,
		0x00, 0x80, 0x66, 0xe6,
		0x00, 0xc0, 0xcc, 0xcc,
		0x00, 0x40, 0x33, 0xb3,
		0x00, 0x80, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xc0, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x01, 0xff, 0xff,
		0x00, 0x01, 0x99, 0x99,
		0x00, 0x01, 0x33, 0x33,
		0x00, 0x00, 0xcc, 0xcc,
		0x00, 0x00, 0x66, 0x66,
		0xff, 0xff, 0x99, 0x9a,
		0xff, 0xff, 0x33, 0x33,
		0xff, 0xfe, 0xcc, 0xcd,
		0xff, 0xfe, 0x66, 0x66,
		0xff, 0xfe, 0x00, 0x00,
		0x00, 0x01, 0xff, 0xff,
		0xff, 0xfe, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo18BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 18;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xc0, 0x00,
		0x66, 0x66, 0x40, 0x00,
		0x4c, 0xcc, 0xc0, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x99, 0x80, 0x00,
		0xe6, 0x66, 0x80, 0x00,
		0xcc, 0xcc, 0xc0, 0x00,
		0xb3, 0x33, 0x40, 0x00,
		0x99, 0x99, 0x80, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xc0, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 19-Bits
//  1.0 0x0003ffff 0x0007fffe
//  0.8 0x00033332 0x00066664
//  0.6 0x00026666 0x0004cccc
//  0.4 0x00019999 0x00033332
//  0.2 0x0000cccd 0x0001999a
// -0.2 0xffff3333 0xfffe6666
// -0.4 0xfffe6666 0xfffccccc
// -0.6 0xfffd999a 0xfffb3334
// -0.8 0xfffccccd 0xfff9999a
// -1.0 0xfffc0000 0xfff80000
//  1.0 0x0003ffff 0x0007fffe
// -1.0 0xfffc0000 0xfff80000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x03,
		0x32, 0x33, 0x03,
		0x66, 0x66, 0x02,
		0x99, 0x99, 0x01,
		0xcd, 0xcc, 0x00,
		0x33, 0x33, 0xff,
		0x66, 0x66, 0xfe,
		0x9a, 0x99, 0xfd,
		0xcd, 0xcc, 0xfc,
		0x00, 0x00, 0xfc,
		0xff, 0xff, 0x03,
		0x00, 0x00, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xe0, 0xff, 0x7f,
		0x40, 0x66, 0x66,
		0xc0, 0xcc, 0x4c,
		0x20, 0x33, 0x33,
		0xa0, 0x99, 0x19,
		0x60, 0x66, 0xe6,
		0xc0, 0xcc, 0xcc,
		0x40, 0x33, 0xb3,
		0xa0, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xe0, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0xff, 0xff,
		0x03, 0x33, 0x32,
		0x02, 0x66, 0x66,
        0x01, 0x99, 0x99,
		0x00, 0xcc, 0xcd,
		0xff, 0x33, 0x33,
		0xfe, 0x66, 0x66,
		0xfd, 0x99, 0x9a,
		0xfc, 0xcc, 0xcd,
		0xfc, 0x00, 0x00,
		0x03, 0xff, 0xff,
		0xfc, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xe0,
		0x66, 0x66, 0x40,
		0x4c, 0xcc, 0xc0,
		0x33, 0x33, 0x20,
		0x19, 0x99, 0xa0,
		0xe6, 0x66, 0x60,
		0xcc, 0xcc, 0xc0,
		0xb3, 0x33, 0x40,
		0x99, 0x99, 0xa0,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xe0,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x03, 0x00,
		0x32, 0x33, 0x03, 0x00,
		0x66, 0x66, 0x02, 0x00,
		0x99, 0x99, 0x01, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0x33, 0xff, 0xff,
		0x66, 0x66, 0xfe, 0xff,
		0x9a, 0x99, 0xfd, 0xff,
		0xcd, 0xcc, 0xfc, 0xff,
		0x00, 0x00, 0xfc, 0xff,
		0xff, 0xff, 0x03, 0x00,
		0x00, 0x00, 0xfc, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xe0, 0xff, 0x7f,
		0x00, 0x40, 0x66, 0x66,
		0x00, 0xc0, 0xcc, 0x4c,
		0x00, 0x20, 0x33, 0x33,
		0x00, 0xa0, 0x99, 0x19,
		0x00, 0x60, 0x66, 0xe6,
		0x00, 0xc0, 0xcc, 0xcc,
		0x00, 0x40, 0x33, 0xb3,
		0x00, 0xa0, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xe0, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x03, 0xff, 0xff,
		0x00, 0x03, 0x33, 0x32,
		0x00, 0x02, 0x66, 0x66,
        0x00, 0x01, 0x99, 0x99,
		0x00, 0x00, 0xcc, 0xcd,
		0xff, 0xff, 0x33, 0x33,
		0xff, 0xfe, 0x66, 0x66,
		0xff, 0xfd, 0x99, 0x9a,
		0xff, 0xfc, 0xcc, 0xcd,
		0xff, 0xfc, 0x00, 0x00,
		0x00, 0x03, 0xff, 0xff,
		0xff, 0xfc, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo19BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 19;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xe0, 0x00,
		0x66, 0x66, 0x40, 0x00,
		0x4c, 0xcc, 0xc0, 0x00,
		0x33, 0x33, 0x20, 0x00,
		0x19, 0x99, 0xa0, 0x00,
		0xe6, 0x66, 0x60, 0x00,
		0xcc, 0xcc, 0xc0, 0x00,
		0xb3, 0x33, 0x40, 0x00,
		0x99, 0x99, 0xa0, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xe0, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 20-Bits
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x07,
		0x66, 0x66, 0x06,
		0xcc, 0xcc, 0x04,
		0x33, 0x33, 0x03,
		0x99, 0x99, 0x01,
		0x66, 0x66, 0xfe,
		0xcd, 0xcc, 0xfc,
		0x33, 0x33, 0xfb,
		0x9a, 0x99, 0xf9,
		0x00, 0x00, 0xf8,
		0xff, 0xff, 0x07,
		0x00, 0x00, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf0, 0xff, 0x7f,
		0x60, 0x66, 0x66,
		0xc0, 0xcc, 0x4c,
		0x30, 0x33, 0x33,
		0x90, 0x99, 0x19,
		0x60, 0x66, 0xe6,
		0xd0, 0xcc, 0xcc,
		0x30, 0x33, 0xb3,
		0xa0, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xf0, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0xFF, 0xFF,
		0x06, 0x66, 0x66,
		0x04, 0xCC, 0xCC,
		0x03, 0x33, 0x33,
		0x01, 0x99, 0x99,
		0xFE, 0x66, 0x66,
		0xFC, 0xCC, 0xCD,
		0xFB, 0x33, 0x33,
		0xF9, 0x99, 0x9A,
		0xF8, 0x00, 0x00,
		0x07, 0xFF, 0xFF,
		0xF8, 0x00, 0x00,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7F, 0xFF, 0xF0,
		0x66, 0x66, 0x60,
		0x4C, 0xCC, 0xC0,
		0x33, 0x33, 0x30,
		0x19, 0x99, 0x90,
		0xE6, 0x66, 0x60,
		0xCC, 0xCC, 0xD0,
		0xB3, 0x33, 0x30,
		0x99, 0x99, 0xA0,
		0x80, 0x00, 0x00,
		0x7F, 0xFF, 0xF0,
		0x80, 0x00, 0x00,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x07, 0x00,
		0x66, 0x66, 0x06, 0x00,
		0xcc, 0xcc, 0x04, 0x00,
		0x33, 0x33, 0x03, 0x00,
		0x99, 0x99, 0x01, 0x00,
		0x66, 0x66, 0xfe, 0xff,
		0xcd, 0xcc, 0xfc, 0xff,
		0x33, 0x33, 0xfb, 0xff,
		0x9a, 0x99, 0xf9, 0xff,
		0x00, 0x00, 0xf8, 0xff,
		0xff, 0xff, 0x07, 0x00,
		0x00, 0x00, 0xf8, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0x7f,
		0x00, 0x60, 0x66, 0x66,
		0x00, 0xc0, 0xcc, 0x4c,
		0x00, 0x30, 0x33, 0x33,
		0x00, 0x90, 0x99, 0x19,
		0x00, 0x60, 0x66, 0xe6,
		0x00, 0xd0, 0xcc, 0xcc,
		0x00, 0x30, 0x33, 0xb3,
		0x00, 0xa0, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xf0, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x07, 0xFF, 0xFF,
		0x00, 0x06, 0x66, 0x66,
		0x00, 0x04, 0xCC, 0xCC,
		0x00, 0x03, 0x33, 0x33,
		0x00, 0x01, 0x99, 0x99,
		0xFF, 0xFE, 0x66, 0x66,
		0xFF, 0xFC, 0xCC, 0xCD,
		0xFF, 0xFB, 0x33, 0x33,
		0xFF, 0xF9, 0x99, 0x9A,
		0xFF, 0xF8, 0x00, 0x00,
		0x00, 0x07, 0xFF, 0xFF,
		0xFF, 0xF8, 0x00, 0x00,
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo20BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7F, 0xFF, 0xF0, 0x00,
		0x66, 0x66, 0x60, 0x00,
		0x4C, 0xCC, 0xC0, 0x00,
		0x33, 0x33, 0x30, 0x00,
		0x19, 0x99, 0x90, 0x00,
		0xE6, 0x66, 0x60, 0x00,
		0xCC, 0xCC, 0xD0, 0x00,
		0xB3, 0x33, 0x30, 0x00,
		0x99, 0x99, 0xA0, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7F, 0xFF, 0xF0, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 21-Bits
//  1.0 0x000fffff 0x007ffff8
//  0.8 0x000ccccc 0x00666660
//  0.6 0x00099999 0x004cccc8
//  0.4 0x00066666 0x00333330
//  0.2 0x00033333 0x00199998
// -0.2 0xfffccccd 0xffe66668
// -0.4 0xfff9999a 0xffccccd0
// -0.6 0xfff66666 0xffb33330
// -0.8 0xfff33333 0xff999998
// -1.0 0xfff00000 0xff800000
//  1.0 0x000fffff 0x007ffff8
// -1.0 0xfff00000 0xff800000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x0f,
		0xcc, 0xcc, 0x0c,
		0x99, 0x99, 0x09,
		0x66, 0x66, 0x06,
		0x33, 0x33, 0x03,
		0xcd, 0xcc, 0xfc,
		0x9a, 0x99, 0xf9,
		0x66, 0x66, 0xf6,
		0x33, 0x33, 0xf3,
		0x00, 0x00, 0xf0,
		0xff, 0xff, 0x0f,
		0x00, 0x00, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf8, 0xff, 0x7f,
		0x60, 0x66, 0x66,
		0xc8, 0xcc, 0x4c,
		0x30, 0x33, 0x33,
		0x98, 0x99, 0x19,
		0x68, 0x66, 0xe6,
		0xd0, 0xcc, 0xcc,
		0x30, 0x33, 0xb3,
		0x98, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xf8, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0xff, 0xff,
		0x0c, 0xcc, 0xcc,
		0x09, 0x99, 0x99,
		0x06, 0x66, 0x66,
		0x03, 0x33, 0x33,
		0xfc, 0xcc, 0xcd,
		0xf9, 0x99, 0x9a,
		0xf6, 0x66, 0x66,
		0xf3, 0x33, 0x33,
		0xf0, 0x00, 0x00,
		0x0f, 0xff, 0xff,
		0xf0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xf8,
		0x66, 0x66, 0x60,
		0x4c, 0xcc, 0xc8,
		0x33, 0x33, 0x30,
		0x19, 0x99, 0x98,
		0xe6, 0x66, 0x68,
		0xcc, 0xcc, 0xd0,
		0xb3, 0x33, 0x30,
		0x99, 0x99, 0x98,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xf8,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff,0xff,0x0f,0x00,
		0xcc,0xcc,0x0c,0x00,
		0x99,0x99,0x09,0x00,
		0x66,0x66,0x06,0x00,
		0x33,0x33,0x03,0x00,
		0xcd,0xcc,0xfc,0xff,
		0x9a,0x99,0xf9,0xff,
		0x66,0x66,0xf6,0xff,
		0x33,0x33,0xf3,0xff,
		0x00,0x00,0xf0,0xff,
		0xff,0xff,0x0f,0x00,
		0x00,0x00,0xf0,0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xf8, 0xff, 0x7f,
		0x00, 0x60, 0x66, 0x66,
		0x00, 0xc8, 0xcc, 0x4c,
		0x00, 0x30, 0x33, 0x33,
		0x00, 0x98, 0x99, 0x19,
		0x00, 0x68, 0x66, 0xe6,
		0x00, 0xd0, 0xcc, 0xcc,
		0x00, 0x30, 0x33, 0xb3,
		0x00, 0x98, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xf8, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x0f, 0xff, 0xff,
		0x00, 0x0c, 0xcc, 0xcc,
		0x00, 0x09, 0x99, 0x99,
		0x00, 0x06, 0x66, 0x66,
		0x00, 0x03, 0x33, 0x33,
		0xff, 0xfc, 0xcc, 0xcd,
		0xff, 0xf9, 0x99, 0x9a,
		0xff, 0xf6, 0x66, 0x66,
		0xff, 0xf3, 0x33, 0x33,
		0xff, 0xf0, 0x00, 0x00,
		0x00, 0x0f, 0xff, 0xff,
		0xff, 0xf0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo21BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 21;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xf8, 0x00,
		0x66, 0x66, 0x60, 0x00,
		0x4c, 0xcc, 0xc8, 0x00,
		0x33, 0x33, 0x30, 0x00,
		0x19, 0x99, 0x98, 0x00,
		0xe6, 0x66, 0x68, 0x00,
		0xcc, 0xcc, 0xd0, 0x00,
		0xb3, 0x33, 0x30, 0x00,
		0x99, 0x99, 0x98, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xf8, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 22-Bits
//  1.0 0x001fffff 0x007ffffc
//  0.8 0x00199999 0x00666664
//  0.6 0x00133333 0x004ccccc
//  0.4 0x000ccccc 0x00333330
//  0.2 0x00066666 0x00199998
// -0.2 0xfff9999a 0xffe66668
// -0.4 0xfff33333 0xffcccccc
// -0.6 0xffeccccd 0xffb33334
// -0.8 0xffe66666 0xff999998
// -1.0 0xffe00000 0xff800000
//  1.0 0x001fffff 0x007ffffc
// -1.0 0xffe00000 0xff800000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x1f,
		0x99, 0x99, 0x19,
		0x33, 0x33, 0x13,
		0xcc, 0xcc, 0x0c,
		0x66, 0x66, 0x06,
		0x9a, 0x99, 0xf9,
		0x33, 0x33, 0xf3,
		0xcd, 0xcc, 0xec,
		0x66, 0x66, 0xe6,
		0x00, 0x00, 0xe0,
		0xff, 0xff, 0x1f,
		0x00, 0x00, 0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfc, 0xff, 0x7f,
		0x64, 0x66, 0x66,
		0xcc, 0xcc, 0x4c,
		0x30, 0x33, 0x33,
		0x98, 0x99, 0x19,
		0x68, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc,
		0x34, 0x33, 0xb3,
		0x98, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xfc, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0xff, 0xff,
		0x19, 0x99, 0x99,
		0x13, 0x33, 0x33,
		0x0c, 0xcc, 0xcc,
		0x06, 0x66, 0x66,
		0xf9, 0x99, 0x9a,
		0xf3, 0x33, 0x33,
		0xec, 0xcc, 0xcd,
		0xe6, 0x66, 0x66,
		0xe0, 0x00, 0x00,
		0x1f, 0xff, 0xff,
		0xe0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xfc,
		0x66, 0x66, 0x64,
		0x4c, 0xcc, 0xcc,
		0x33, 0x33, 0x30,
		0x19, 0x99, 0x98,
		0xe6, 0x66, 0x68,
		0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x34,
		0x99, 0x99, 0x98,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xfc,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x1f, 0x00,
		0x99, 0x99, 0x19, 0x00,
		0x33, 0x33, 0x13, 0x00,
		0xcc, 0xcc, 0x0c, 0x00,
		0x66, 0x66, 0x06, 0x00,
		0x9a, 0x99, 0xf9, 0xff,
		0x33, 0x33, 0xf3, 0xff,
		0xcd, 0xcc, 0xec, 0xff,
		0x66, 0x66, 0xe6, 0xff,
		0x00, 0x00, 0xe0, 0xff,
		0xff, 0xff, 0x1f, 0x00,
		0x00, 0x00, 0xe0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xfc, 0xff, 0x7f,
		0x00, 0x64, 0x66, 0x66,
		0x00, 0xcc, 0xcc, 0x4c,
		0x00, 0x30, 0x33, 0x33,
		0x00, 0x98, 0x99, 0x19,
		0x00, 0x68, 0x66, 0xe6,
		0x00, 0xcc, 0xcc, 0xcc,
		0x00, 0x34, 0x33, 0xb3,
		0x00, 0x98, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xfc, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 22;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x1f, 0xff, 0xff,
		0x00, 0x19, 0x99, 0x99,
		0x00, 0x13, 0x33, 0x33,
		0x00, 0x0c, 0xcc, 0xcc,
		0x00, 0x06, 0x66, 0x66,
		0xff, 0xf9, 0x99, 0x9a,
		0xff, 0xf3, 0x33, 0x33,
		0xff, 0xec, 0xcc, 0xcd,
		0xff, 0xe6, 0x66, 0x66,
		0xff, 0xe0, 0x00, 0x00,
		0x00, 0x1f, 0xff, 0xff,
		0xff, 0xe0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo22BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 22;
    const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xfc, 0x00,
		0x66, 0x66, 0x64, 0x00,
		0x4c, 0xcc, 0xcc, 0x00,
		0x33, 0x33, 0x30, 0x00,
		0x19, 0x99, 0x98, 0x00,
		0xe6, 0x66, 0x68, 0x00,
		0xcc, 0xcc, 0xcc, 0x00,
		0xb3, 0x33, 0x34, 0x00,
		0x99, 0x99, 0x98, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xfc, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 23-Bits
//  1.0 0x003fffff 0x007ffffe
//  0.8 0x00333332 0x00666664
//  0.6 0x00266666 0x004ccccc
//  0.4 0x00199999 0x00333332
//  0.2 0x000ccccd 0x0019999a
// -0.2 0xfff33333 0xffe66666
// -0.4 0xffe66666 0xffcccccc
// -0.6 0xffd9999a 0xffb33334
// -0.8 0xffcccccd 0xff99999a
// -1.0 0xffc00000 0xff800000
//  1.0 0x003fffff 0x007ffffe
// -1.0 0xffc00000 0xff800000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndian24BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x3f,
		0x32, 0x33, 0x33,
		0x66, 0x66, 0x26,
		0x99, 0x99, 0x19,
		0xcd, 0xcc, 0x0c,
		0x33, 0x33, 0xf3,
		0x66, 0x66, 0xe6,
		0x9a, 0x99, 0xd9,
		0xcd, 0xcc, 0xcc,
		0x00, 0x00, 0xc0,
		0xff, 0xff, 0x3f,
		0x00, 0x00, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndianUnsigned24BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f,
		0x32, 0x33, 0x73,
		0x66, 0x66, 0x66,
		0x99, 0x99, 0x59,
		0xcd, 0xcc, 0x4c,
		0x33, 0x33, 0x33,
		0x66, 0x66, 0x26,
		0x9a, 0x99, 0x19,
		0xcd, 0xcc, 0x0c,
		0x00, 0x00, 0x00,
		0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00
	};
		
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndian24BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0xff, 0x7f,
		0x64, 0x66, 0x66,
		0xcc, 0xcc, 0x4c,
		0x32, 0x33, 0x33,
		0x9a, 0x99, 0x19,
		0x66, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc,
		0x34, 0x33, 0xb3,
		0x9a, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xfe, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndianUnsigned24BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0xff, 0xff,
		0x64, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc,
		0x32, 0x33, 0xb3,
		0x9a, 0x99, 0x99,
		0x66, 0x66, 0x66,
		0xcc, 0xcc, 0x4c,
		0x34, 0x33, 0x33,
		0x9a, 0x99, 0x19,
		0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff,
		0x00, 0x00, 0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndian24BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0xff, 0xff,
		0x33, 0x33, 0x32,
		0x26, 0x66, 0x66,
		0x19, 0x99, 0x99,
		0x0c, 0xcc, 0xcd,
		0xf3, 0x33, 0x33,
		0xe6, 0x66, 0x66,
		0xd9, 0x99, 0x9a,
		0xcc, 0xcc, 0xcd,
		0xc0, 0x00, 0x00,
		0x3f, 0xff, 0xff,
		0xc0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndianUnsigned24BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff,
		0x73, 0x33, 0x32,
		0x66, 0x66, 0x66,
		0x59, 0x99, 0x99,
		0x4c, 0xcc, 0xcd,
		0x33, 0x33, 0x33,
		0x26, 0x66, 0x66,
		0x19, 0x99, 0x9a,
		0x0c, 0xcc, 0xcd,
		0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff,
		0x00, 0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndian24BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xfe,
		0x66, 0x66, 0x64,
		0x4c, 0xcc, 0xcc,
		0x33, 0x33, 0x32,
		0x19, 0x99, 0x9a,
		0xe6, 0x66, 0x66,
		0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x34,
		0x99, 0x99, 0x9a,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xfe,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndianUnsigned24BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xfe,
		0xe6, 0x66, 0x64,
		0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x32,
		0x99, 0x99, 0x9a,
		0x66, 0x66, 0x66,
		0x4c, 0xcc, 0xcc,
		0x33, 0x33, 0x34,
		0x19, 0x99, 0x9a,
		0x00, 0x00, 0x00,
		0xff, 0xff, 0xfe,
		0x00, 0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x3f, 0x00,
		0x32, 0x33, 0x33, 0x00,
		0x66, 0x66, 0x26, 0x00,
		0x99, 0x99, 0x19, 0x00,
		0xcd, 0xcc, 0x0c, 0x00,
		0x33, 0x33, 0xf3, 0xff,
		0x66, 0x66, 0xe6, 0xff,
		0x9a, 0x99, 0xd9, 0xff,
		0xcd, 0xcc, 0xcc, 0xff,
		0x00, 0x00, 0xc0, 0xff,
		0xff, 0xff, 0x3f, 0x00,
		0x00, 0x00, 0xc0, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xfe, 0xff, 0x7f,
		0x00,0x64,0x66,0x66,
		0x00,0xcc,0xcc,0x4c,
		0x00,0x32,0x33,0x33,
		0x00,0x9a,0x99,0x19,
		0x00,0x66,0x66,0xe6,
		0x00,0xcc,0xcc,0xcc,
		0x00,0x34,0x33,0xb3,
		0x00,0x9a,0x99,0x99,
		0x00,0x00,0x00,0x80,
		0x00,0xfe,0xff,0x7f,
		0x00,0x00,0x00,0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x3f, 0xff, 0xff,
		0x00, 0x33, 0x33, 0x32,
		0x00, 0x26, 0x66, 0x66,
		0x00, 0x19, 0x99, 0x99,
		0x00, 0x0c, 0xcc, 0xcd,
		0xff, 0xf3, 0x33, 0x33,
		0xff, 0xe6, 0x66, 0x66,
		0xff, 0xd9, 0x99, 0x9a,
		0xff, 0xcc, 0xcc, 0xcd,
		0xff, 0xc0, 0x00, 0x00,
		0x00, 0x3f, 0xff, 0xff,
		0xff, 0xc0, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo23BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xfe, 0x00,
		0x66, 0x66, 0x64, 0x00,
		0x4c, 0xcc, 0xcc, 0x00,
		0x33, 0x33, 0x32, 0x00,
		0x19, 0x99, 0x9a, 0x00,
		0xe6, 0x66, 0x66, 0x00,
		0xcc, 0xcc, 0xcc, 0x00,
		0xb3, 0x33, 0x34, 0x00,
		0x99, 0x99, 0x9a, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xfe, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 24-Bits
//  1.0 0x007fffff 0x07fffff0
//  0.8 0x00666666 0x06666660
//  0.6 0x004ccccc 0x04ccccc0
//  0.4 0x00333333 0x03333330
//  0.2 0x00199999 0x01999990
// -0.2 0xffe66666 0xfe666660
// -0.4 0xffcccccd 0xfcccccd0
// -0.6 0xffb33333 0xfb333330
// -0.8 0xff99999a 0xf99999a0
// -1.0 0xff800000 0xf8000000
//  1.0 0x007fffff 0x07fffff0
// -1.0 0xff800000 0xf8000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInLittleEndian24Bits)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f,
		0x66, 0x66, 0x66,
		0xcc, 0xcc, 0x4c,
		0x33, 0x33, 0x33,
		0x99, 0x99, 0x19,
		0x66, 0x66, 0xe6,
		0xcd, 0xcc, 0xcc,
		0x33, 0x33, 0xb3,
		0x9a, 0x99, 0x99,
		0x00, 0x00, 0x80,
		0xff, 0xff, 0x7f,
		0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInLittleEndianUnsigned24Bits)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] ={
		0xff,0xff,0xff,
		0x66,0x66,0xe6,
		0xcc,0xcc,0xcc,
		0x33,0x33,0xb3,
		0x99,0x99,0x99,
		0x66,0x66,0x66,
		0xcd,0xcc,0x4c,
		0x33,0x33,0x33,
		0x9a,0x99,0x19,
		0x00,0x00,0x00,
		0xff,0xff,0xff,
		0x00,0x00,0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInBigEndian24Bits)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff,
		0x66, 0x66, 0x66,
		0x4c, 0xcc, 0xcc,
		0x33, 0x33, 0x33,
		0x19, 0x99, 0x99,
		0xe6, 0x66, 0x66,
		0xcc, 0xcc, 0xcd,
		0xb3, 0x33, 0x33,
		0x99, 0x99, 0x9a,
		0x80, 0x00, 0x00,
		0x7f, 0xff, 0xff,
		0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInBigEndianUnsigned24Bits)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] ={
		0xff,0xff,0xff,
		0xe6,0x66,0x66,
		0xcc,0xcc,0xcc,
		0xb3,0x33,0x33,
		0x99,0x99,0x99,
		0x66,0x66,0x66,
		0x4c,0xcc,0xcd,
		0x33,0x33,0x33,
		0x19,0x99,0x9a,
		0x00,0x00,0x00,
		0xff,0xff,0xff,
		0x00,0x00,0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00,
		0x66, 0x66, 0x66, 0x00,
		0xcc, 0xcc, 0x4c, 0x00,
		0x33, 0x33, 0x33, 0x00,
		0x99, 0x99, 0x19, 0x00,
		0x66, 0x66, 0xe6, 0xff,
		0xcd, 0xcc, 0xcc, 0xff,
		0x33, 0x33, 0xb3, 0xff,
		0x9a, 0x99, 0x99, 0xff,
		0x00, 0x00, 0x80, 0xff,
		0xff, 0xff, 0x7f, 0x00,
		0x00, 0x00, 0x80, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f,
		0x00, 0x66, 0x66, 0x66,
		0x00, 0xcc, 0xcc, 0x4c,
		0x00, 0x33, 0x33, 0x33,
		0x00, 0x99, 0x99, 0x19,
		0x00, 0x66, 0x66, 0xe6,
		0x00, 0xcd, 0xcc, 0xcc,
		0x00, 0x33, 0x33, 0xb3,
		0x00, 0x9a, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x00, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0xff,
		0x00, 0x66, 0x66, 0x66,
		0x00, 0x4c, 0xcc, 0xcc,
		0x00, 0x33, 0x33, 0x33,
		0x00, 0x19, 0x99, 0x99,
		0xff, 0xe6, 0x66, 0x66,
		0xff, 0xcc, 0xcc, 0xcd,
		0xff, 0xb3, 0x33, 0x33,
		0xff, 0x99, 0x99, 0x9a,
		0xff, 0x80, 0x00, 0x00,
		0x00, 0x7f, 0xff, 0xff,
		0xff, 0x80, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo24BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00,
		0x66, 0x66, 0x66, 0x00,
		0x4c, 0xcc, 0xcc, 0x00,
		0x33, 0x33, 0x33, 0x00,
		0x19, 0x99, 0x99, 0x00,
		0xe6, 0x66, 0x66, 0x00,
		0xcc, 0xcc, 0xcd, 0x00,
		0xb3, 0x33, 0x33, 0x00,
		0x99, 0x99, 0x9a, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 25-Bits
//  1.0 0x00ffffff 0x07fffff8
//  0.8 0x00cccccc 0x06666660
//  0.6 0x00999999 0x04ccccc8
//  0.4 0x00666666 0x03333330
//  0.2 0x00333333 0x01999998
// -0.2 0xffcccccd 0xfe666668
// -0.4 0xff99999a 0xfcccccd0
// -0.6 0xff666666 0xfb333330
// -0.8 0xff333333 0xf9999998
// -1.0 0xff000000 0xf8000000
//  1.0 0x00ffffff 0x07fffff8
// -1.0 0xff000000 0xf8000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo25BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 25;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00,
		0xcc, 0xcc, 0xcc, 0x00,
		0x99, 0x99, 0x99, 0x00,
		0x66, 0x66, 0x66, 0x00,
		0x33, 0x33, 0x33, 0x00,
		0xcd, 0xcc, 0xcc, 0xff,
		0x9a, 0x99, 0x99, 0xff,
		0x66, 0x66, 0x66, 0xff,
		0x33, 0x33, 0x33, 0xff,
		0x00, 0x00, 0x00, 0xff,
		0xff, 0xff, 0xff, 0x00,
		0x00, 0x00, 0x00, 0xff
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo25BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 25;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x80, 0xff, 0xff, 0x7f,
		0x00, 0x66, 0x66, 0x66,
		0x80, 0xcc, 0xcc, 0x4c,
		0x00, 0x33, 0x33, 0x33,
		0x80, 0x99, 0x99, 0x19,
		0x80, 0x66, 0x66, 0xe6,
		0x00, 0xcd, 0xcc, 0xcc,
		0x00, 0x33, 0x33, 0xb3,
		0x80, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0x80, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo25BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 25;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff,
		0x00, 0xcc, 0xcc, 0xcc,
		0x00, 0x99, 0x99, 0x99,
		0x00, 0x66, 0x66, 0x66,
		0x00, 0x33, 0x33, 0x33,
		0xff, 0xcc, 0xcc, 0xcd,
		0xff, 0x99, 0x99, 0x9a,
		0xff, 0x66, 0x66, 0x66,
		0xff, 0x33, 0x33, 0x33,
		0xff, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo25BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 25;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x80,
		0x66, 0x66, 0x66, 0x00,
		0x4c, 0xcc, 0xcc, 0x80,
		0x33, 0x33, 0x33, 0x00,
		0x19, 0x99, 0x99, 0x80,
		0xe6, 0x66, 0x66, 0x80,
		0xcc, 0xcc, 0xcd, 0x00,
		0xb3, 0x33, 0x33, 0x00,
		0x99, 0x99, 0x99, 0x80,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0x80,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 26-Bits
//  1.0 0x01ffffff 0x07fffffc
//  0.8 0x01999999 0x06666664
//  0.6 0x01333333 0x04cccccc
//  0.4 0x00cccccc 0x03333330
//  0.2 0x00666666 0x01999998
// -0.2 0xff99999a 0xfe666668
// -0.4 0xff333333 0xfccccccc
// -0.6 0xfecccccd 0xfb333334
// -0.8 0xfe666666 0xf9999998
// -1.0 0xfe000000 0xf8000000
//  1.0 0x01ffffff 0x07fffffc
// -1.0 0xfe000000 0xf8000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo26BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 26;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x01,
		0x99, 0x99, 0x99, 0x01,
		0x33, 0x33, 0x33, 0x01,
		0xcc, 0xcc, 0xcc, 0x00,
		0x66, 0x66, 0x66, 0x00,
		0x9a, 0x99, 0x99, 0xff,
		0x33, 0x33, 0x33, 0xff,
		0xcd, 0xcc, 0xcc, 0xfe,
		0x66, 0x66, 0x66, 0xfe,
		0x00, 0x00, 0x00, 0xfe,
		0xff, 0xff, 0xff, 0x01,
		0x00, 0x00, 0x00, 0xfe
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo26BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 26;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xc0, 0xff, 0xff, 0x7f,
		0x40, 0x66, 0x66, 0x66,
		0xc0, 0xcc, 0xcc, 0x4c,
		0x00, 0x33, 0x33, 0x33,
		0x80, 0x99, 0x99, 0x19,
		0x80, 0x66, 0x66, 0xe6,
		0xc0, 0xcc, 0xcc, 0xcc,
		0x40, 0x33, 0x33, 0xb3,
		0x80, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xc0, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo26BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 26;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x01, 0xff, 0xff, 0xff,
		0x01, 0x99, 0x99, 0x99,
		0x01, 0x33, 0x33, 0x33,
		0x00, 0xcc, 0xcc, 0xcc,
		0x00, 0x66, 0x66, 0x66,
		0xff, 0x99, 0x99, 0x9a,
		0xff, 0x33, 0x33, 0x33,
		0xfe, 0xcc, 0xcc, 0xcd,
		0xfe, 0x66, 0x66, 0x66,
		0xfe, 0x00, 0x00, 0x00,
		0x01, 0xff, 0xff, 0xff,
		0xfe, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo26BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 26;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xc0,
		0x66, 0x66, 0x66, 0x40,
		0x4c, 0xcc, 0xcc, 0xc0,
		0x33, 0x33, 0x33, 0x00,
		0x19, 0x99, 0x99, 0x80,
		0xe6, 0x66, 0x66, 0x80,
		0xcc, 0xcc, 0xcc, 0xc0,
		0xb3, 0x33, 0x33, 0x40,
		0x99, 0x99, 0x99, 0x80,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xc0,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 27-Bits
//  1.0 0x03ffffff 0x07fffffe
//  0.8 0x03333332 0x06666664
//  0.6 0x02666666 0x04cccccc
//  0.4 0x01999999 0x03333332
//  0.2 0x00cccccd 0x0199999a
// -0.2 0xff333333 0xfe666666
// -0.4 0xfe666666 0xfccccccc
// -0.6 0xfd99999a 0xfb333334
// -0.8 0xfccccccd 0xf999999a
// -1.0 0xfc000000 0xf8000000
//  1.0 0x03ffffff 0x07fffffe
// -1.0 0xfc000000 0xf8000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo27BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 27;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x03,
		0x32, 0x33, 0x33, 0x03,
		0x66, 0x66, 0x66, 0x02,
		0x99, 0x99, 0x99, 0x01,
		0xcd, 0xcc, 0xcc, 0x00,
		0x33, 0x33, 0x33, 0xff,
		0x66, 0x66, 0x66, 0xfe,
		0x9a, 0x99, 0x99, 0xfd,
		0xcd, 0xcc, 0xcc, 0xfc,
		0x00, 0x00, 0x00, 0xfc,
		0xff, 0xff, 0xff, 0x03,
		0x00, 0x00, 0x00, 0xfc
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo27BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 27;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xe0, 0xff, 0xff, 0x7f,
		0x40, 0x66, 0x66, 0x66,
		0xc0, 0xcc, 0xcc, 0x4c,
		0x20, 0x33, 0x33, 0x33,
		0xa0, 0x99, 0x99, 0x19,
		0x60, 0x66, 0x66, 0xe6,
		0xc0, 0xcc, 0xcc, 0xcc,
		0x40, 0x33, 0x33, 0xb3,
		0xa0, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xe0, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo27BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 27;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x03, 0xff, 0xff, 0xff,
		0x03, 0x33, 0x33, 0x32,
		0x02, 0x66, 0x66, 0x66,
		0x01, 0x99, 0x99, 0x99,
		0x00, 0xcc, 0xcc, 0xcd,
		0xff, 0x33, 0x33, 0x33,
		0xfe, 0x66, 0x66, 0x66,
		0xfd, 0x99, 0x99, 0x9a,
		0xfc, 0xcc, 0xcc, 0xcd,
		0xfc, 0x00, 0x00, 0x00,
		0x03, 0xff, 0xff, 0xff,
		0xfc, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo27BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 27;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xe0,
		0x66, 0x66, 0x66, 0x40,
		0x4c, 0xcc, 0xcc, 0xc0,
		0x33, 0x33, 0x33, 0x20,
		0x19, 0x99, 0x99, 0xa0,
		0xe6, 0x66, 0x66, 0x60,
		0xcc, 0xcc, 0xcc, 0xc0,
		0xb3, 0x33, 0x33, 0x40,
		0x99, 0x99, 0x99, 0xa0,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xe0,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 28-Bits
//  1.0 0x07ffffff 0x7ffffff0
//  0.8 0x06666666 0x66666660
//  0.6 0x04cccccc 0x4cccccc0
//  0.4 0x03333333 0x33333330
//  0.2 0x01999999 0x19999990
// -0.2 0xfe666666 0xe6666660
// -0.4 0xfccccccd 0xccccccd0
// -0.6 0xfb333333 0xb3333330
// -0.8 0xf999999a 0x999999a0
// -1.0 0xf8000000 0x80000000
//  1.0 0x07ffffff 0x7ffffff0
// -1.0 0xf8000000 0x80000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo28BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x07,
		0x66, 0x66, 0x66, 0x06,
		0xcc, 0xcc, 0xcc, 0x04,
		0x33, 0x33, 0x33, 0x03,
		0x99, 0x99, 0x99, 0x01,
		0x66, 0x66, 0x66, 0xfe,
		0xcd, 0xcc, 0xcc, 0xfc,
		0x33, 0x33, 0x33, 0xfb,
		0x9a, 0x99, 0x99, 0xf9,
		0x00, 0x00, 0x00, 0xf8,
		0xff, 0xff, 0xff, 0x07,
		0x00, 0x00, 0x00, 0xf8
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo28BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0x7f,
		0x60, 0x66, 0x66, 0x66,
		0xc0, 0xcc, 0xcc, 0x4c,
		0x30, 0x33, 0x33, 0x33,
		0x90, 0x99, 0x99, 0x19,
		0x60, 0x66, 0x66, 0xe6,
		0xd0, 0xcc, 0xcc, 0xcc,
		0x30, 0x33, 0x33, 0xb3,
		0xa0, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xf0, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo28BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x07, 0xff, 0xff, 0xff,
		0x06, 0x66, 0x66, 0x66,
		0x04, 0xcc, 0xcc, 0xcc,
		0x03, 0x33, 0x33, 0x33,
		0x01, 0x99, 0x99, 0x99,
		0xfe, 0x66, 0x66, 0x66,
		0xfc, 0xcc, 0xcc, 0xcd,
		0xfb, 0x33, 0x33, 0x33,
		0xf9, 0x99, 0x99, 0x9a,
		0xf8, 0x00, 0x00, 0x00,
		0x07, 0xff, 0xff, 0xff,
		0xf8, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo28BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xf0,
		0x66, 0x66, 0x66, 0x60,
		0x4c, 0xcc, 0xcc, 0xc0,
		0x33, 0x33, 0x33, 0x30,
		0x19, 0x99, 0x99, 0x90,
		0xe6, 0x66, 0x66, 0x60,
		0xcc, 0xcc, 0xcc, 0xd0,
		0xb3, 0x33, 0x33, 0x30,
		0x99, 0x99, 0x99, 0xa0,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xf0,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 29-Bits
//  1.0 0x0fffffff 0x7ffffff8
//  0.8 0x0ccccccc 0x66666660
//  0.6 0x09999999 0x4cccccc8
//  0.4 0x06666666 0x33333330
//  0.2 0x03333333 0x19999998
// -0.2 0xfccccccd 0xe6666668
// -0.4 0xf999999a 0xccccccd0
// -0.6 0xf6666666 0xb3333330
// -0.8 0xf3333333 0x99999998
// -1.0 0xf0000000 0x80000000
//  1.0 0x0fffffff 0x7ffffff8
// -1.0 0xf0000000 0x80000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo29BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 29;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x0f,
		0xcc, 0xcc, 0xcc, 0x0c,
		0x99, 0x99, 0x99, 0x09,
		0x66, 0x66, 0x66, 0x06,
		0x33, 0x33, 0x33, 0x03,
		0xcd, 0xcc, 0xcc, 0xfc,
		0x9a, 0x99, 0x99, 0xf9,
		0x66, 0x66, 0x66, 0xf6,
		0x33, 0x33, 0x33, 0xf3,
		0x00, 0x00, 0x00, 0xf0,
		0xff, 0xff, 0xff, 0x0f,
		0x00, 0x00, 0x00, 0xf0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo29BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 29;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xf8, 0xff, 0xff, 0x7f,
		0x60, 0x66, 0x66, 0x66,
		0xc8, 0xcc, 0xcc, 0x4c,
		0x30, 0x33, 0x33, 0x33,
		0x98, 0x99, 0x99, 0x19,
		0x68, 0x66, 0x66, 0xe6,
		0xd0, 0xcc, 0xcc, 0xcc,
		0x30, 0x33, 0x33, 0xb3,
		0x98, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xf8, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo29BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 29;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x0f, 0xff, 0xff, 0xff,
		0x0c, 0xcc, 0xcc, 0xcc,
		0x09, 0x99, 0x99, 0x99,
		0x06, 0x66, 0x66, 0x66,
		0x03, 0x33, 0x33, 0x33,
		0xfc, 0xcc, 0xcc, 0xcd,
		0xf9, 0x99, 0x99, 0x9a,
		0xf6, 0x66, 0x66, 0x66,
		0xf3, 0x33, 0x33, 0x33,
		0xf0, 0x00, 0x00, 0x00,
		0x0f, 0xff, 0xff, 0xff,
		0xf0, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo29BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 29;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xf8,
		0x66, 0x66, 0x66, 0x60,
		0x4c, 0xcc, 0xcc, 0xc8,
		0x33, 0x33, 0x33, 0x30,
		0x19, 0x99, 0x99, 0x98,
		0xe6, 0x66, 0x66, 0x68,
		0xcc, 0xcc, 0xcc, 0xd0,
		0xb3, 0x33, 0x33, 0x30,
		0x99, 0x99, 0x99, 0x98,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xf8,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 30-Bits
//  1.0 0x1fffffff 0x7ffffffc
//  0.8 0x19999999 0x66666664
//  0.6 0x13333333 0x4ccccccc
//  0.4 0x0ccccccc 0x33333330
//  0.2 0x06666666 0x19999998
// -0.2 0xf999999a 0xe6666668
// -0.4 0xf3333333 0xcccccccc
// -0.6 0xeccccccd 0xb3333334
// -0.8 0xe6666666 0x99999998
// -1.0 0xe0000000 0x80000000
//  1.0 0x1fffffff 0x7ffffffc
// -1.0 0xe0000000 0x80000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo30BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 30;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x1f,
		0x99, 0x99, 0x99, 0x19,
		0x33, 0x33, 0x33, 0x13,
		0xcc, 0xcc, 0xcc, 0x0c,
		0x66, 0x66, 0x66, 0x06,
		0x9a, 0x99, 0x99, 0xf9,
		0x33, 0x33, 0x33, 0xf3,
		0xcd, 0xcc, 0xcc, 0xec,
		0x66, 0x66, 0x66, 0xe6,
		0x00, 0x00, 0x00, 0xe0,
		0xff, 0xff, 0xff, 0x1f,
		0x00, 0x00, 0x00, 0xe0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo30BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 30;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfc, 0xff, 0xff, 0x7f,
		0x64, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0x4c,
		0x30, 0x33, 0x33, 0x33,
		0x98, 0x99, 0x99, 0x19,
		0x68, 0x66, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc, 0xcc,
		0x34, 0x33, 0x33, 0xb3,
		0x98, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xfc, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo30BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 30;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x1f, 0xff, 0xff, 0xff,
		0x19, 0x99, 0x99, 0x99,
		0x13, 0x33, 0x33, 0x33,
		0x0c, 0xcc, 0xcc, 0xcc,
		0x06, 0x66, 0x66, 0x66,
		0xf9, 0x99, 0x99, 0x9a,
		0xf3, 0x33, 0x33, 0x33,
		0xec, 0xcc, 0xcc, 0xcd,
		0xe6, 0x66, 0x66, 0x66,
		0xe0, 0x00, 0x00, 0x00,
		0x1f, 0xff, 0xff, 0xff,
		0xe0, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo30BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 30;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xfc,
		0x66, 0x66, 0x66, 0x64,
		0x4c, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0x30,
		0x19, 0x99, 0x99, 0x98,
		0xe6, 0x66, 0x66, 0x68,
		0xcc, 0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x33, 0x34,
		0x99, 0x99, 0x99, 0x98,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xfc,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 31-Bits
//  1.0 0x3fffffff 0x7ffffffe
//  0.8 0x33333332 0x66666664
//  0.6 0x26666666 0x4ccccccc
//  0.4 0x19999999 0x33333332
//  0.2 0x0ccccccd 0x1999999a
// -0.2 0xf3333333 0xe6666666
// -0.4 0xe6666666 0xcccccccc
// -0.6 0xd999999a 0xb3333334
// -0.8 0xcccccccd 0x9999999a
// -1.0 0xc0000000 0x80000000
//  1.0 0x3fffffff 0x7ffffffe
// -1.0 0xc0000000 0x80000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x3f,
		0x32, 0x33, 0x33, 0x33,
		0x66, 0x66, 0x66, 0x26,
		0x99, 0x99, 0x99, 0x19,
		0xcd, 0xcc, 0xcc, 0x0c,
		0x33, 0x33, 0x33, 0xf3,
		0x66, 0x66, 0x66, 0xe6,
		0x9a, 0x99, 0x99, 0xd9,
		0xcd, 0xcc, 0xcc, 0xcc,
		0x00, 0x00, 0x00, 0xc0,
		0xff, 0xff, 0xff, 0x3f,
		0x00, 0x00, 0x00, 0xc0
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInLittleEndianUnsigned32BitsLSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x7f,
		0x32, 0x33, 0x33, 0x73,
		0x66, 0x66, 0x66, 0x66,
		0x99, 0x99, 0x99, 0x59,
		0xcd, 0xcc, 0xcc, 0x4c,
		0x33, 0x33, 0x33, 0x33,
		0x66, 0x66, 0x66, 0x26,
		0x9a, 0x99, 0x99, 0x19,
		0xcd, 0xcc, 0xcc, 0x0c,
		0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x00
	};
	
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInLittleEndian32BitsMSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0xff, 0xff, 0x7f,
		0x64, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0x4c,
		0x32, 0x33, 0x33, 0x33,
		0x9a, 0x99, 0x99, 0x19,
		0x66, 0x66, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc, 0xcc,
		0x34, 0x33, 0x33, 0xb3,
		0x9a, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xfe, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInLittleEndianUnsigned32BitsMSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xfe, 0xff, 0xff, 0xff,
		0x64, 0x66, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc, 0xcc,
		0x32, 0x33, 0x33, 0xb3,
		0x9a, 0x99, 0x99, 0x99,
		0x66, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0x4c,
		0x34, 0x33, 0x33, 0x33,
		0x9a, 0x99, 0x99, 0x19,
		0x00, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInBigEndian32BitsLSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x3f, 0xff, 0xff, 0xff,
		0x33, 0x33, 0x33, 0x32,
		0x26, 0x66, 0x66, 0x66,
		0x19, 0x99, 0x99, 0x99,
		0x0c, 0xcc, 0xcc, 0xcd,
		0xf3, 0x33, 0x33, 0x33,
		0xe6, 0x66, 0x66, 0x66,
		0xd9, 0x99, 0x99, 0x9a,
		0xcc, 0xcc, 0xcc, 0xcd,
		0xc0, 0x00, 0x00, 0x00,
		0x3f, 0xff, 0xff, 0xff,
		0xc0, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInBigEndianUnsigned32BitsLSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] ={
		0x7f,0xff,0xff,0xff,
		0x73,0x33,0x33,0x32,
		0x66,0x66,0x66,0x66,
		0x59,0x99,0x99,0x99,
		0x4c,0xcc,0xcc,0xcd,
		0x33,0x33,0x33,0x33,
		0x26,0x66,0x66,0x66,
		0x19,0x99,0x99,0x9a,
		0x0c,0xcc,0xcc,0xcd,
		0x00,0x00,0x00,0x00,
		0x7f,0xff,0xff,0xff,
		0x00,0x00,0x00,0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif

	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xfe,
		0x66, 0x66, 0x66, 0x64,
		0x4c, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0x32,
		0x19, 0x99, 0x99, 0x9a,
		0xe6, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x33, 0x34,
		0x99, 0x99, 0x99, 0x9a,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xfe,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo31BitSampleInBigEndianUnsigned32BitsMSB)
{
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xfe,
		0xe6, 0x66, 0x66, 0x64,
		0xcc, 0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x33, 0x32,
		0x99, 0x99, 0x99, 0x9a,
		0x66, 0x66, 0x66, 0x66,
		0x4c, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0x34,
		0x19, 0x99, 0x99, 0x9a,
		0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xfe,
		0x00, 0x00, 0x00, 0x00
	};
		
	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 32-Bits
//  1.0 0x7fffffff 0xfffffff0
//  0.8 0x66666666 0x66666660
//  0.6 0x4ccccccc 0xccccccc0
//  0.4 0x33333333 0x33333330
//  0.2 0x19999999 0x99999990
// -0.2 0xe6666666 0x66666660
// -0.4 0xcccccccd 0xccccccd0
// -0.6 0xb3333333 0x33333330
// -0.8 0x9999999a 0x999999a0
// -1.0 0x80000000 0x00000000
//  1.0 0x7fffffff 0xfffffff0
// -1.0 0x80000000 0x00000000
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo32BitSampleInLittleEndian32BitsLSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x7f,
		0x66, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0x4c,
		0x33, 0x33, 0x33, 0x33,
		0x99, 0x99, 0x99, 0x19,
		0x66, 0x66, 0x66, 0xe6,
		0xcd, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0xb3,
		0x9a, 0x99, 0x99, 0x99,
		0x00, 0x00, 0x00, 0x80,
		0xff, 0xff, 0xff, 0x7f,
		0x00, 0x00, 0x00, 0x80
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo32BitSampleInLittleEndianUnsigned32BitsLSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff,
		0x66, 0x66, 0x66, 0xe6,
		0xcc, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0xb3,
		0x99, 0x99, 0x99, 0x99,
		0x66, 0x66, 0x66, 0x66,
		0xcd, 0xcc, 0xcc, 0x4c,
		0x33, 0x33, 0x33, 0x33,
		0x9a, 0x99, 0x99, 0x19,
		0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo32BitSampleInBigEndian32BitsMSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xff,
		0x66, 0x66, 0x66, 0x66,
		0x4c, 0xcc, 0xcc, 0xcc,
		0x33, 0x33, 0x33, 0x33,
		0x19, 0x99, 0x99, 0x99,
		0xe6, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0xcd,
		0xb3, 0x33, 0x33, 0x33,
		0x99, 0x99, 0x99, 0x9a,
		0x80, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xff,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesTo32BitSampleInBigEndianUnsigned32BitsMSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[12] = {
		1.0f, 0.8f, 0.6f, 0.4f, 0.2f, -0.2f, -0.4f, -0.6f, -0.8f, -1.0f, 1.2f, -1.2f
	};
#else
	const sample_t c_sampleInput[12] = {
		1.0, 0.8, 0.6, 0.4, 0.2, -0.2, -0.4, -0.6, -0.8, -1.0, 1.2, -1.2
	};
#endif
	
	const tubyte c_expectOutput[12 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff,
		0xe6, 0x66, 0x66, 0x66,
		0xcc, 0xcc, 0xcc, 0xcc,
		0xb3, 0x33, 0x33, 0x33,
		0x99, 0x99, 0x99, 0x99,
		0x66, 0x66, 0x66, 0x66,
		0x4c, 0xcc, 0xcc, 0xcd,
		0x33, 0x33, 0x33, 0x33,
		0x19, 0x99, 0x99, 0x9a,
		0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00
	};

	testSampleUnsignedConvertion(c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// Channel increment tests
//-------------------------------------------------------------------------------------------

void testSampleConvertionForChannelInterleave(tint noInChannels,tint noOutChannels,tint noBits,tint bytesPerSample,bool littleEndian,bool alignHigh,const sample_t *samples,const tubyte *expect)
{
    tubyte *out = new tubyte [12 * noOutChannels * bytesPerSample];
	memset(out,0,12 * noOutChannels * bytesPerSample);
	
    SampleConverter sampleConverter(noBits,bytesPerSample,littleEndian,alignHigh,true);
	sampleConverter.setNumberOfInputChannels(noInChannels);
	sampleConverter.setNumberOfOutputChannels(noOutChannels);
	
	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
    EXPECT_EQ(noInChannels,sampleConverter.numberOfInputChannels());
    EXPECT_EQ(noOutChannels,sampleConverter.numberOfOutputChannels());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	
	sampleConverter.convert(samples,out,12);
	
	testSampleOutputConvertion(expect,out,noBits,bytesPerSample,12 * noOutChannels);
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamples8BitsLSBWith2Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 2;
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
	
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x3f, 0x00,
		0x32, 0x00,
		0x26, 0x00,
		0x19, 0x00,
		0x0d, 0x00,
		0xf3, 0x00,
		0xe6, 0x00,
		0xda, 0x00,
		0xcd, 0x00,
		0xc0, 0x00,
		0x3f, 0x00,
		0xc0, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamples8BitsMSBWith4Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 4;
	const tint c_noBits = 7;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x7e, 0x00, 0x00, 0x00,
		0x64, 0x00, 0x00, 0x00,
		0x4c, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcc, 0x00, 0x00, 0x00,
		0xb4, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
		0x7e, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian16BitsLSBWith2Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 2;
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
	
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xff, 0x3f, 0x00, 0x00,
		0x32, 0x33, 0x00, 0x00,
		0x66, 0x26, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0xcd, 0x0c, 0x00, 0x00,
		0x33, 0xf3, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0x9a, 0xd9, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x00, 0xc0, 0x00, 0x00,
		0xff, 0x3f, 0x00, 0x00,
		0x00, 0xc0, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian16BitsMSBWith3Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 3;
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x64, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x32, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x34, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian16BitsLSBWith4Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 4;
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd9, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian16BitsMSBWith8Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 8;
	const tint c_noBits = 15;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian24BitsLSBWith2Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 2;
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xff, 0xff, 0x3f, 0x00, 0x00, 0x00,
		0x32, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x26, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x19, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x0c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xf3, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xd9, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x3f, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xc0, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian24BitsMSBWith4Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 4;
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xfe, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x64, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x32, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x34, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian24BitsLSBWith6Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 6;
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
	
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd9, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x3f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian24BitsMSBWith8Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 8;
	const tint c_noBits = 23;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian32BitsLSBWith2Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 2;
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
	
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00,
		0x32, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x26, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xf3, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0xd9, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesLittleEndian32BitsMSBWith3Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 3;
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x64, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x32, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x34, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian32BitsLSBWith4Channels)
{
	const tint c_noInChannels = 2;
	const tint c_noOutChannels = 4;
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 
		 0.8f, 0.7f,
		 0.6f, 0.7f,
		 0.4f, 0.7f,
		 0.2f, 0.7f,
		-0.2f, 0.7f,
		-0.4f, 0.7f,
		-0.6f, 0.7f,
		-0.8f, 0.7f,
		-1.0f, 0.7f,
		 1.2f, 0.7f,
		-1.2f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 
		 0.8, 0.7,
		 0.6, 0.7,
		 0.4, 0.7,
		 0.2, 0.7,
		-0.2, 0.7,
		-0.4, 0.7,
		-0.6, 0.7,
		-0.8, 0.7,
		-1.0, 0.7,
		 1.2, 0.7,
		-1.2, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd9, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,doubleSamplesBigEndian32BitsMSBWith5Channels)
{
	const tint c_noInChannels = 4;
	const tint c_noOutChannels = 5;
	const tint c_noBits = 31;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;

#if defined(SINGLE_FLOAT_SAMPLE)
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0f, 0.7f, 0.7f, 0.7f,
		 0.8f, 0.7f, 0.7f, 0.7f,
		 0.6f, 0.7f, 0.7f, 0.7f,
		 0.4f, 0.7f, 0.7f, 0.7f,
		 0.2f, 0.7f, 0.7f, 0.7f,
		-0.2f, 0.7f, 0.7f, 0.7f,
		-0.4f, 0.7f, 0.7f, 0.7f,
		-0.6f, 0.7f, 0.7f, 0.7f,
		-0.8f, 0.7f, 0.7f, 0.7f,
		-1.0f, 0.7f, 0.7f, 0.7f,
		 1.2f, 0.7f, 0.7f, 0.7f,
		-1.2f, 0.7f, 0.7f, 0.7f
	};
#else
    const sample_t c_sampleInput[12 * c_noInChannels] = {
		 1.0, 0.7, 0.7, 0.7,
		 0.8, 0.7, 0.7, 0.7,
		 0.6, 0.7, 0.7, 0.7,
		 0.4, 0.7, 0.7, 0.7,
		 0.2, 0.7, 0.7, 0.7,
		-0.2, 0.7, 0.7, 0.7,
		-0.4, 0.7, 0.7, 0.7,
		-0.6, 0.7, 0.7, 0.7,
		-0.8, 0.7, 0.7, 0.7,
		-1.0, 0.7, 0.7, 0.7,
		 1.2, 0.7, 0.7, 0.7,
		-1.2, 0.7, 0.7, 0.7
	};
#endif
		
	const tubyte c_expectOutput[12 * c_noOutChannels * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testSampleConvertionForChannelInterleave(c_noInChannels,c_noOutChannels,c_noBits,c_bytesPerSample,c_littleEndian,c_alignHigh,c_sampleInput,c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 4-Bits Signed
//           4LSB/8, 4MSB/8, 4LSB/16-LE, 4LSB/16-BE, 4MSB/16-LE, 4MSB/16-BE,
// 0x7fff ->   0x07,   0x70,  0x07 0x00,  0x00 0x07,  0x00 0x70,  0x70 0x00,
// 0x6666 ->   0x06,   0x60,  0x06 0x00,  0x00 0x06,  0x00 0x60,  0x60 0x00,
// 0x4ccc ->   0x05,   0x50,  0x05 0x00,  0x00 0x05,  0x00 0x50,  0x50 0x00,
// 0x3333 ->   0x03,   0x30,  0x03 0x00,  0x00 0x03,  0x00 0x30,  0x30 0x00,
// 0x1999 ->   0x02,   0x20,  0x02 0x00,  0x00 0x02,  0x00 0x20,  0x20 0x00,
// 0xe666 ->   0xfe,   0xe0,  0xfe 0xff,  0xff 0xfe,  0x00 0xe0,  0xe0 0x00,
// 0xcccd ->   0xfd,   0xd0,  0xfd 0xff,  0xff 0xfd,  0x00 0xd0,  0xd0 0x00,
// 0xb333 ->   0xfb,   0xb0,  0xfb 0xff,  0xff 0xfb,  0x00 0xb0,  0xb0 0x00,
// 0x999a ->   0xfa,   0xa0,  0xfa 0xff,  0xff 0xfa,  0x00 0xa0,  0xa0 0x00,
// 0x8000 ->   0xf8,   0x80,  0xf8 0xff,  0xff 0xf8,  0x00 0x80,  0x80 0x00,
//
//     4LSB/24-LE,      4LSB/24-BE,      4MSB/24-LE,      4MSB/24-BE,
// 0x07 0x00 0x00,  0x00 0x00 0x07,  0x00 0x00 0x70,  0x70 0x00 0x00,
// 0x06 0x00 0x00,  0x00 0x00 0x06,  0x00 0x00 0x60,  0x60 0x00 0x00,
// 0x05 0x00 0x00,  0x00 0x00 0x05,  0x00 0x00 0x50,  0x50 0x00 0x00,
// 0x03 0x00 0x00,  0x00 0x00 0x03,  0x00 0x00 0x30,  0x30 0x00 0x00,
// 0x02 0x00 0x00,  0x00 0x00 0x02,  0x00 0x00 0x20,  0x20 0x00 0x00,
// 0x0e 0xff 0xff,  0xff 0xff 0xfe,  0x00 0x00 0xe0,  0xe0 0x00 0x00,
// 0x0d 0xff 0xff,  0xff 0xff 0xfd,  0x00 0x00 0xd0,  0xd0 0x00 0x00,
// 0x0b 0xff 0xff,  0xff 0xff 0xfb,  0x00 0x00 0xb0,  0xb0 0x00 0x00,
// 0x0a 0xff 0xff,  0xff 0xff 0xfa,  0x00 0x00 0xa0,  0xa0 0x00 0x00,
// 0x08 0xff 0xff,  0xff 0xff 0xf8,  0x00 0x00 0x80,  0x80 0x00 0x00,
//
//          4LSB/32-LE,           4LSB/32-BE,           4MSB/32-LE,           4MSB/32-BE,
// 0x07 0x00 0x00 0x00,  0x00 0x00 0x00 0x07,  0x00 0x00 0x00 0x70,  0x70 0x00 0x00 0x00,
// 0x06 0x00 0x00 0x00,  0x00 0x00 0x00 0x06,  0x00 0x00 0x00 0x60,  0x60 0x00 0x00 0x00,
// 0x05 0x00 0x00 0x00,  0x00 0x00 0x00 0x05,  0x00 0x00 0x00 0x50,  0x50 0x00 0x00 0x00,
// 0x03 0x00 0x00 0x00,  0x00 0x00 0x00 0x03,  0x00 0x00 0x00 0x30,  0x30 0x00 0x00 0x00,
// 0x02 0x00 0x00 0x00,  0x00 0x00 0x00 0x02,  0x00 0x00 0x00 0x20,  0x20 0x00 0x00 0x00,
// 0x0e 0xff 0xff 0xff,  0xff 0xff 0xff 0xfe,  0x00 0x00 0x00 0xe0,  0xe0 0x00 0x00 0x00,
// 0x0d 0xff 0xff 0xff,  0xff 0xff 0xff 0xfd,  0x00 0x00 0x00 0xd0,  0xd0 0x00 0x00 0x00,
// 0x0b 0xff 0xff 0xff,  0xff 0xff 0xff 0xfb,  0x00 0x00 0x00 0xb0,  0xb0 0x00 0x00 0x00,
// 0x0a 0xff 0xff 0xff,  0xff 0xff 0xff 0xfa,  0x00 0x00 0x00 0xa0,  0xa0 0x00 0x00 0x00,
// 0x08 0xff 0xff 0xff,  0xff 0xff 0xff 0xf8,  00x00 x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

void testInt16A24A32Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect)
{
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tuint16 c_int16Samples[c_noSamples * c_noChannels] = {
		0x7fff, 0x1111,
		0x6666, 0x1111,
		0x4ccc, 0x1111,
		0x3333, 0x1111,
		0x1999, 0x1111,
		0xe666, 0x1111,
		0xcccd, 0x1111,
		0xb333, 0x1111,
		0x999a, 0x1111,
		0x8000, 0x1111,
	};
	const tuint32 c_int24Samples[c_noSamples * c_noChannels] = {
		0x007fffff, 0x00111111,
		0x00666666, 0x00111111,
		0x004ccccc, 0x00111111,
		0x00333333, 0x00111111,
		0x00199999, 0x00111111,
		0xffe66666, 0x00111111,
		0xffcccccd, 0x00111111,
		0xffb33333, 0x00111111,
		0xff99999a, 0x00111111,
		0xff800000, 0x00111111
	};
	const tuint32 c_int32Samples[c_noSamples * c_noChannels] = {
		0x7fffffff, 0x11111111,
		0x66666666, 0x11111111,
		0x4ccccccc, 0x11111111,
		0x33333333, 0x11111111,
		0x19999999, 0x11111111,
		0xe6666666, 0x11111111,
		0xcccccccd, 0x11111111,
		0xb3333333, 0x11111111,
		0x9999999a, 0x11111111,
		0x80000000, 0x11111111
	};
	
	int outputSize = c_noSamples * c_noChannels * bytesPerSample;
    tubyte *out = new tubyte [outputSize];
	
	SampleConverter sampleConverter(noBits, bytesPerSample, littleEndian, alignHigh, isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	if(isSigned)
	{
		EXPECT_EQ(FormatDescription::e_DataSignedInteger,sampleConverter.type());
	}
	else
	{
		EXPECT_EQ(FormatDescription::e_DataUnsignedInteger,sampleConverter.type());
	}
	
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(2,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(2,sampleConverter.numberOfOutputChannels());
	
	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int16Samples), out, c_noSamples, engine::e_SampleInt16);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));

	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int24Samples), out, c_noSamples, engine::e_SampleInt24);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));

	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int32Samples), out, c_noSamples, engine::e_SampleInt32);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));	
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleIn8BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2] = {
		0x07, 0x00,
		0x06, 0x00,
		0x05, 0x00,
		0x03, 0x00,
		0x02, 0x00,
		0xfe, 0x00,
		0xfd, 0x00,
		0xfb, 0x00,
		0xfa, 0x00,
		0xf8, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleIn8BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2] = {
		0x70, 0x00,
		0x60, 0x00,
		0x50, 0x00,
		0x30, 0x00,
		0x20, 0x00,
		0xe0, 0x00,
		0xd0, 0x00,
		0xb0, 0x00,
		0xa0, 0x00,
		0x80, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE16BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x07, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0x00, 0x00,
		0xfd, 0xff, 0x00, 0x00,
		0xfb, 0xff, 0x00, 0x00,
		0xfa, 0xff, 0x00, 0x00,
		0xf8, 0xff, 0x00, 0x00,
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE16BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x07, 0x00, 0x00,
		0x00, 0x06, 0x00, 0x00,
		0x00, 0x05, 0x00, 0x00,
		0x00, 0x03, 0x00, 0x00,
		0x00, 0x02, 0x00, 0x00,
		0xff, 0xfe, 0x00, 0x00,
		0xff, 0xfd, 0x00, 0x00,
		0xff, 0xfb, 0x00, 0x00,
		0xff, 0xfa, 0x00, 0x00,
		0xff, 0xf8, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE16BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x70, 0x00, 0x00,
		0x00, 0x60, 0x00, 0x00,
		0x00, 0x50, 0x00, 0x00,
		0x00, 0x30, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00,
		0x00, 0xe0, 0x00, 0x00,
		0x00, 0xd0, 0x00, 0x00,
		0x00, 0xb0, 0x00, 0x00,
		0x00, 0xa0, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE16BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x70, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xfd, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xfb, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xfa, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xf8, 0xff, 0xff, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfe, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfd, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfb, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfa, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xf8, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xfd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xfb, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xfa, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xf8, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00

	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xfd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xfb, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xfa, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 4-Bit Unsigned
//                         4LSB/8, 4MSB/8, 4LSB/16-LE, 4LSB/16-BE, 4MSB/16-LE, 4MSB/16-BE,
// 0x7fff ->   0xf8 + 0x07 = 0x0f,   0xf0,  0x0f 0x00,  0x00 0x0f,  0x00 0xf0,  0xf0 0x00,
// 0x6666 ->   0xf8 + 0x06 = 0x0e,   0xe0,  0x0e 0x00,  0x00 0x0e,  0x00 0xe0,  0xe0 0x00,
// 0x4ccc ->   0xf8 + 0x05 = 0x0d,   0xd0,  0x0d 0x00,  0x00 0x0d,  0x00 0xd0,  0xd0 0x00,
// 0x3333 ->   0xf8 + 0x03 = 0x0b,   0xb0,  0x0b 0x00,  0x00 0x0b,  0x00 0xb0,  0xb0 0x00,
// 0x1999 ->   0xf8 + 0x02 = 0x0a,   0xa0,  0x0a 0x00,  0x00 0x0a,  0x00 0xa0,  0xa0 0x00,
// 0xe666 ->   0xfe - 0xf8 = 0x06,   0x60,  0x06 0x00,  0x00 0x06,  0x00 0x60,  0x60 0x00,
// 0xcccd ->   0xfd - 0xf8 = 0x05,   0x50,  0x05 0x00,  0x00 0x05,  0x00 0x50,  0x50 0x00,
// 0xb333 ->   0xfb - 0xf8 = 0x03,   0x30,  0x03 0x00,  0x00 0x03,  0x00 0x30,  0x30 0x00,
// 0x999a ->   0xfa - 0xf8 = 0x02,   0x20,  0x02 0x00,  0x00 0x02,  0x00 0x20,  0x20 0x00,
// 0x8000 ->   0xf8 - 0xf8 = 0x00,   0x00,  0x00 0x00,  0x00 0x00,  0x00 0x00,  0x00 0x00,
//     4LSB/24-LE,      4LSB/24-BE,      4MSB/24-LE,      4MSB/24-BE,
// 0x0f 0x00 0x00,  0x00 0x00 0x0f,  0x00 0x00 0xf0,  0xf0 0x00 0x00,
// 0x0e 0x00 0x00,  0x00 0x00 0x0e,  0x00 0x00 0xe0,  0xe0 0x00 0x00,
// 0x0d 0x00 0x00,  0x00 0x00 0x0d,  0x00 0x00 0xd0,  0xd0 0x00 0x00,
// 0x0b 0x00 0x00,  0x00 0x00 0x0b,  0x00 0x00 0xb0,  0xb0 0x00 0x00,
// 0x0a 0x00 0x00,  0x00 0x00 0x0a,  0x00 0x00 0xa0,  0xa0 0x00 0x00,
// 0x06 0x00 0x00,  0x00 0x00 0x06,  0x00 0x00 0x60,  0x60 0x00 0x00,
// 0x05 0x00 0x00,  0x00 0x00 0x05,  0x00 0x00 0x50,  0x50 0x00 0x00,
// 0x03 0x00 0x00,  0x00 0x00 0x03,  0x00 0x00 0x30,  0x30 0x00 0x00,
// 0x02 0x00 0x00,  0x00 0x00 0x02,  0x00 0x00 0x20,  0x20 0x00 0x00,
// 0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,
//          4LSB/32-LE,           4LSB/32-BE,           4MSB/32-LE,           4MSB/32-BE,
// 0x0f 0x00 0x00 0x00,  0x00 0x00 0x00 0x0f,  0x00 0x00 0x00 0xf0,  0xf0 0x00 0x00 0x00,
// 0x0e 0x00 0x00 0x00,  0x00 0x00 0x00 0x0e,  0x00 0x00 0x00 0xe0,  0xe0 0x00 0x00 0x00,
// 0x0d 0x00 0x00 0x00,  0x00 0x00 0x00 0x0d,  0x00 0x00 0x00 0xd0,  0xd0 0x00 0x00 0x00,
// 0x0b 0x00 0x00 0x00,  0x00 0x00 0x00 0x0b,  0x00 0x00 0x00 0xb0,  0xb0 0x00 0x00 0x00,
// 0x0a 0x00 0x00 0x00,  0x00 0x00 0x00 0x0a,  0x00 0x00 0x00 0xa0,  0xa0 0x00 0x00 0x00,
// 0x06 0x00 0x00 0x00,  0x00 0x00 0x00 0x06,  0x00 0x00 0x00 0x60,  0x60 0x00 0x00 0x00,
// 0x05 0x00 0x00 0x00,  0x00 0x00 0x00 0x05,  0x00 0x00 0x00 0x50,  0x50 0x00 0x00 0x00,
// 0x03 0x00 0x00 0x00,  0x00 0x00 0x00 0x03,  0x00 0x00 0x00 0x30,  0x30 0x00 0x00 0x00,
// 0x02 0x00 0x00 0x00,  0x00 0x00 0x00 0x02,  0x00 0x00 0x00 0x20,  0x20 0x00 0x00 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleIn8BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x0f, 0x00,
		0x0e, 0x00,
		0x0d, 0x00,
		0x0b, 0x00,
		0x0a, 0x00,
		0x06, 0x00,
		0x05, 0x00,
		0x03, 0x00,
		0x02, 0x00,
		0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleIn8BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0x00,
		0xe0, 0x00,
		0xd0, 0x00,
		0xb0, 0x00,
		0xa0, 0x00,
		0x60, 0x00,
		0x50, 0x00,
		0x30, 0x00,
		0x20, 0x00,
		0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE16BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x0f, 0x00, 0x00, 0x00,
		0x0e, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x00, 0x00,
		0x0b, 0x00, 0x00, 0x00,
		0x0a, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE16BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x0f, 0x00, 0x00,
		0x00, 0x0e, 0x00, 0x00,
		0x00, 0x0d, 0x00, 0x00,
		0x00, 0x0b, 0x00, 0x00,
		0x00, 0x0a, 0x00, 0x00,
		0x00, 0x06, 0x00, 0x00,
		0x00, 0x05, 0x00, 0x00,
		0x00, 0x03, 0x00, 0x00,
		0x00, 0x02, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE16BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0x00, 0x00,
		0x00, 0xe0, 0x00, 0x00,
		0x00, 0xd0, 0x00, 0x00,
		0x00, 0xb0, 0x00, 0x00,
		0x00, 0xa0, 0x00, 0x00,
		0x00, 0x60, 0x00, 0x00,
		0x00, 0x50, 0x00, 0x00,
		0x00, 0x30, 0x00, 0x00,
		0x00, 0x20, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE16BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xf0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo4BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 4;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 8-Bits Signed
//           8LSB/8, 8MSB/8, 8LSB/16-LE, 8LSB/16-BE, 8MSB/16-LE, 8MSB/16-BE,
// 0x7fff ->   0x7f,   0x7f,  0x7f 0x00,  0x00 0x7f,  0x00 0x7f,  0x7f 0x00,
// 0x6666 ->   0x66,   0x66,  0x66 0x00,  0x00 0x66,  0x00 0x66,  0x66 0x00,
// 0x4ccc ->   0x4d,   0x4d,  0x4d 0x00,  0x00 0x4d,  0x00 0x4d,  0x4d 0x00,
// 0x3333 ->   0x33,   0x33,  0x33 0x00,  0x00 0x33,  0x00 0x33,  0x33 0x00,
// 0x1999 ->   0x1a,   0x1a,  0x1a 0x00,  0x00 0x1a,  0x00 0x1a,  0x1a 0x00,
// 0xe666 ->   0xe6,   0xe6,  0xe6 0xff,  0xff 0xe6,  0x00 0xe6,  0xe6 0x00,
// 0xcccd ->   0xcd,   0xcd,  0xcd 0xff,  0xff 0xcd,  0x00 0xcd,  0xcd 0x00,
// 0xb333 ->   0xb3,   0xb3,  0xb3 0xff,  0xff 0xb3,  0x00 0xb3,  0xb3 0x00,
// 0x999a ->   0x9a,   0x9a,  0x9a 0xff,  0xff 0x9a,  0x00 0x9a,  0x9a 0x00,
// 0x8000 ->   0x80,   0x80,  0x80 0xff,  0xff 0x80,  0x00 0x80,  0x80 0x00,
//
//     8LSB/24-LE,      8LSB/24-BE,      8MSB/24-LE,      8MSB/24-BE,
// 0x7f 0x00 0x00,  0x00 0x00 0x7f,  0x00 0x00 0x7f,  0x7f 0x00 0x00,
// 0x66 0x00 0x00,  0x00 0x00 0x66,  0x00 0x00 0x66,  0x66 0x00 0x00,
// 0x4d 0x00 0x00,  0x00 0x00 0x4d,  0x00 0x00 0x4d,  0x4d 0x00 0x00,
// 0x33 0x00 0x00,  0x00 0x00 0x33,  0x00 0x00 0x33,  0x33 0x00 0x00,
// 0x1a 0x00 0x00,  0x00 0x00 0x1a,  0x00 0x00 0x1a,  0x1a 0x00 0x00,
// 0xe6 0xff 0xff,  0xff 0xff 0xe6,  0x00 0x00 0xe6,  0xe6 0x00 0x00,
// 0xcd 0xff 0xff,  0xff 0xff 0xcd,  0x00 0x00 0xcd,  0xcd 0x00 0x00,
// 0xb3 0xff 0xff,  0xff 0xff 0xb3,  0x00 0x00 0xb3,  0xb3 0x00 0x00,
// 0x9a 0xff 0xff,  0xff 0xff 0x9a,  0x00 0x00 0x9a,  0x9a 0x00 0x00,
// 0x80 0xff 0xff,  0xff 0xff 0x80,  0x00 0x00 0x80,  0x80 0x00 0x00,
//
//          8LSB/32-LE,           8LSB/32-BE,           8MSB/32-LE,           8MSB/32-BE,
// 0x7f 0x00 0x00 0x00,  0x00 0x00 0x00 0x7f,  0x00 0x00 0x00 0x7f,  0x7f 0x00 0x00 0x00,
// 0x66 0x00 0x00 0x00,  0x00 0x00 0x00 0x66,  0x00 0x00 0x00 0x66,  0x66 0x00 0x00 0x00,
// 0x4d 0x00 0x00 0x00,  0x00 0x00 0x00 0x4d,  0x00 0x00 0x00 0x4d,  0x4d 0x00 0x00 0x00,
// 0x33 0x00 0x00 0x00,  0x00 0x00 0x00 0x33,  0x00 0x00 0x00 0x33,  0x33 0x00 0x00 0x00,
// 0x1a 0x00 0x00 0x00,  0x00 0x00 0x00 0x1a,  0x00 0x00 0x00 0x1a,  0x1a 0x00 0x00 0x00,
// 0xe6 0xff 0xff 0xff,  0xff 0xff 0xff 0xe6,  0x00 0x00 0x00 0xe6,  0xe6 0x00 0x00 0x00,
// 0xcd 0xff 0xff 0xff,  0xff 0xff 0xff 0xcd,  0x00 0x00 0x00 0xcd,  0xcd 0x00 0x00 0x00,
// 0xb3 0xff 0xff 0xff,  0xff 0xff 0xff 0xb3,  0x00 0x00 0x00 0xb3,  0xb3 0x00 0x00 0x00,
// 0x9a 0xff 0xff 0xff,  0xff 0xff 0xff 0x9a,  0x00 0x00 0x00 0x9a,  0x9a 0x00 0x00 0x00,
// 0x80 0xff 0xff 0xff,  0xff 0xff 0xff 0x80,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleIn8BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00,
		0x66, 0x00,
		0x4d, 0x00,
		0x33, 0x00,
		0x1a, 0x00,
		0xe6, 0x00,
		0xcd, 0x00,
		0xb3, 0x00,
		0x9a, 0x00,
		0x80, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleIn8BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00,
		0x66, 0x00,
		0x4d, 0x00,
		0x33, 0x00,
		0x1a, 0x00,
		0xe6, 0x00,
		0xcd, 0x00,
		0xb3, 0x00,
		0x9a, 0x00,
		0x80, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE16BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0xe6, 0xff, 0x00, 0x00,
		0xcd, 0xff, 0x00, 0x00,
		0xb3, 0xff, 0x00, 0x00,
		0x9a, 0xff, 0x00, 0x00,
		0x80, 0xff, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE16BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0x00, 0x00,
		0x00, 0x66, 0x00, 0x00,
		0x00, 0x4d, 0x00, 0x00,
		0x00, 0x33, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00,
		0xff, 0xe6, 0x00, 0x00,
		0xff, 0xcd, 0x00, 0x00,
		0xff, 0xb3, 0x00, 0x00,
		0xff, 0x9a, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00,
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE16BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0x00, 0x00,
		0x00, 0x66, 0x00, 0x00,
		0x00, 0x4d, 0x00, 0x00,
		0x00, 0x33, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00,
		0x00, 0xe6, 0x00, 0x00,
		0x00, 0xcd, 0x00, 0x00,
		0x00, 0xb3, 0x00, 0x00,
		0x00, 0x9a, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE16BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xcd, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xb3, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x9a, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x80, 0xff, 0xff, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xe6, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xcd, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xb3, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x80, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 8-Bits Unsigned
//                         8LSB/8, 8MSB/8, 8LSB/16-LE, 8LSB/16-BE, 8MSB/16-LE, 8MSB/16-BE,
// 0x7fff ->   0x7f + 0x80 = 0xff,   0xff,  0xff 0x00,  0x00 0xff,  0x00 0xff,  0xff 0x00,
// 0x6666 ->   0x66 + 0x80 = 0xe6,   0xe6,  0xe6 0x00,  0x00 0xe6,  0x00 0xe6,  0xe6 0x00,
// 0x4ccc ->   0x4d + 0x80 = 0xcd,   0xcd,  0xcd 0x00,  0x00 0xcd,  0x00 0xcd,  0xcd 0x00,
// 0x3333 ->   0x33 + 0x80 = 0xb3,   0xb3,  0xb3 0x00,  0x00 0xb3,  0x00 0xb3,  0xb3 0x00,
// 0x1999 ->   0x1a + 0x80 = 0x9a,   0x9a,  0x9a 0x00,  0x00 0x9a,  0x00 0x9a,  0x9a 0x00,
// 0xe666 ->   0xe6 - 0x80 = 0x66,   0x66,  0x66 0x00,  0x00 0x66,  0x00 0x66,  0x66 0x00,
// 0xcccd ->   0xcd - 0x80 = 0x4d,   0x4d,  0x4d 0x00,  0x00 0x4d,  0x00 0x4d,  0x4d 0x00,
// 0xb333 ->   0xb3 - 0x80 = 0x33,   0x33,  0x33 0x00,  0x00 0x33,  0x00 0x33,  0x33 0x00,
// 0x999a ->   0x9a - 0x80 = 0x1a,   0x1a,  0x1a 0x00,  0x00 0x1a,  0x00 0x1a,  0x1a 0x00,
// 0x8000 ->   0x80 - 0x80 = 0x00,   0x00,  0x00 0x00,  0x00 0x00,  0x00 0x00,  0x00 0x00,
//
//     8LSB/24-LE,      8LSB/24-BE,      8MSB/24-LE,      8MSB/24-BE,
// 0xff 0x00 0x00,  0x00 0x00 0xff,  0x00 0x00 0xff,  0xff 0x00 0x00,
// 0xe6 0x00 0x00,  0x00 0x00 0xe6,  0x00 0x00 0xe6,  0xe6 0x00 0x00,
// 0xcd 0x00 0x00,  0x00 0x00 0xcd,  0x00 0x00 0xcd,  0xcd 0x00 0x00,
// 0xb3 0x00 0x00,  0x00 0x00 0xb3,  0x00 0x00 0xb3,  0xb3 0x00 0x00,
// 0x9a 0x00 0x00,  0x00 0x00 0x9a,  0x00 0x00 0x9a,  0x9a 0x00 0x00,
// 0x66 0x00 0x00,  0x00 0x00 0x66,  0x00 0x00 0x66,  0x66 0x00 0x00,
// 0x4d 0x00 0x00,  0x00 0x00 0x4d,  0x00 0x00 0x4d,  0x4d 0x00 0x00,
// 0x33 0x00 0x00,  0x00 0x00 0x33,  0x00 0x00 0x33,  0x33 0x00 0x00,
// 0x1a 0x00 0x00,  0x00 0x00 0x1a,  0x00 0x00 0x1a,  0x1a 0x00 0x00,
// 0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,
//
//          8LSB/32-LE,           8LSB/32-BE,           8MSB/32-LE,           8MSB/32-BE,
// 0xff 0x00 0x00 0x00,  0x00 0x00 0x00 0xff,  0x00 0x00 0x00 0xff,  0xff 0x00 0x00 0x00,
// 0xe6 0x00 0x00 0x00,  0x00 0x00 0x00 0xe6,  0x00 0x00 0x00 0xe6,  0xe6 0x00 0x00 0x00,
// 0xcd 0x00 0x00 0x00,  0x00 0x00 0x00 0xcd,  0x00 0x00 0x00 0xcd,  0xcd 0x00 0x00 0x00,
// 0xb3 0x00 0x00 0x00,  0x00 0x00 0x00 0xb3,  0x00 0x00 0x00 0xb3,  0xb3 0x00 0x00 0x00,
// 0x9a 0x00 0x00 0x00,  0x00 0x00 0x00 0x9a,  0x00 0x00 0x00 0x9a,  0x9a 0x00 0x00 0x00,
// 0x66 0x00 0x00 0x00,  0x00 0x00 0x00 0x66,  0x00 0x00 0x00 0x66,  0x66 0x00 0x00 0x00,
// 0x4d 0x00 0x00 0x00,  0x00 0x00 0x00 0x4d,  0x00 0x00 0x00 0x4d,  0x4d 0x00 0x00 0x00,
// 0x33 0x00 0x00 0x00,  0x00 0x00 0x00 0x33,  0x00 0x00 0x00 0x33,  0x33 0x00 0x00 0x00,
// 0x1a 0x00 0x00 0x00,  0x00 0x00 0x00 0x1a,  0x00 0x00 0x00 0x1a,  0x1a 0x00 0x00 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleIn8BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00,
		0xe6, 0x00,
		0xcd, 0x00,
		0xb3, 0x00,
		0x9a, 0x00,
		0x66, 0x00,
		0x4d, 0x00,
		0x33, 0x00,
		0x1a, 0x00,
		0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleIn8BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 1;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00,
		0xe6, 0x00,
		0xcd, 0x00,
		0xb3, 0x00,
		0x9a, 0x00,
		0x66, 0x00,
		0x4d, 0x00,
		0x33, 0x00,
		0x1a, 0x00,
		0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE16BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE16BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x00, 0x00,
		0x00, 0xe6, 0x00, 0x00,
		0x00, 0xcd, 0x00, 0x00,
		0x00, 0xb3, 0x00, 0x00,
		0x00, 0x9a, 0x00, 0x00,
		0x00, 0x66, 0x00, 0x00,
		0x00, 0x4d, 0x00, 0x00,
		0x00, 0x33, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE16BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x00, 0x00,
		0x00, 0xe6, 0x00, 0x00,
		0x00, 0xcd, 0x00, 0x00,
		0x00, 0xb3, 0x00, 0x00,
		0x00, 0x9a, 0x00, 0x00,
		0x00, 0x66, 0x00, 0x00,
		0x00, 0x4d, 0x00, 0x00,
		0x00, 0x33, 0x00, 0x00,
		0x00, 0x1a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE16BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4d, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x4d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo8BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 8;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 12-Bits Signed
//           12LSB/8, 12MSB/8, 12LSB/16-LE, 12LSB/16-BE, 12MSB/16-LE, 12MSB/16-BE,
// 0x7fff ->    0x7f,    0x7f,   0xff 0x07,   0x07 0xff,   0xf0 0x7f,   0x7f 0xf0,
// 0x6666 ->    0x66,    0x66,   0x66 0x06,   0x06 0x66,   0x60 0x66,   0x66 0x60,
// 0x4ccc ->    0x4d,    0x4d,   0xcd 0x04,   0x04 0xcd,   0xd0 0x4c,   0x4c 0xd0,
// 0x3333 ->    0x33,    0x33,   0x33 0x03,   0x03 0x33,   0x30 0x33,   0x33 0x30,
// 0x1999 ->    0x1a,    0x1a,   0x9a 0x01,   0x01 0x9a,   0xa0 0x19,   0x19 0xa0,
// 0xe666 ->    0xe6,    0xe6,   0x66 0xfe,   0xfe 0x66,   0x60 0xe6,   0xe6 0x60,
// 0xcccd ->    0xcd,    0xcd,   0xcd 0xfc,   0xfc 0xcd,   0xd0 0xcc,   0xcc 0xd0,
// 0xb333 ->    0xb3,    0xb3,   0x33 0xfb,   0xfb 0x33,   0x30 0xb3,   0xb3 0x30,
// 0x999a ->    0x9a,    0x9a,   0x9a 0xf9,   0xf9 0x9a,   0xa0 0x99,   0x99 0xa0,
// 0x8000 ->    0x80,    0x80,   0x00 0xf8,   0xf8 0x00,   0x00 0x80,   0x80 0x00,
//
//     12LSB/24-LE,      12LSB/24-BE,      12MSB/24-LE,      12MSB/24-BE,
//  0xff 0x07 0x00,   0x00 0x07 0xff,  0x00 0xf0 0x7f,    0x7f 0xf0 0x00,
//  0x66 0x06 0x00,   0x00 0x06 0x66,  0x00 0x60 0x66,    0x66 0x60 0x00,
//  0xcd 0x04 0x00,   0x00 0x04 0xcd,  0x00 0xd0 0x4c,    0x4c 0xd0 0x00,
//  0x33 0x03 0x00,   0x00 0x03 0x33,  0x00 0x30 0x33,    0x33 0x30 0x00,
//  0x9a 0x01 0x00,   0x00 0x01 0x9a,  0x00 0xa0 0x19,    0x19 0xa0 0x00,
//  0x66 0xfe 0xff,   0xff 0xfe 0x66,  0x00 0x60 0xe6,    0xe6 0x60 0x00,
//  0xcd 0xfc 0xff,   0xff 0xfc 0xcd,  0x00 0xd0 0xcc,    0xcc 0xd0 0x00,
//  0x33 0xfb 0xff,   0xff 0xfb 0x33,  0x00 0x30 0xb3,    0xb3 0x30 0x00,
//  0x9a 0xf9 0xff,   0xff 0xf9 0x9a,  0x00 0xa0 0x99,    0x99 0xa0 0x00,
//  0x00 0xf8 0xff,   0xff 0xf8 0x00,  0x00 0x00 0x80,    0x80 0x00 0x00,
// 
//         12LSB/32-LE,            12LSB/32-BE,          12MSB/32-LE,      12MSB/32-BE,
//  0xff 0x07 0x00 0x00,   0x00 0x00 0x07 0xff,  0x00 0x00 0xf0 0x7f,    0x7f 0xf0 0x00 0x00,
//  0x66 0x06 0x00 0x00,   0x00 0x00 0x06 0x66,  0x00 0x00 0x60 0x66,    0x66 0x60 0x00 0x00,
//  0xcd 0x04 0x00 0x00,   0x00 0x00 0x04 0xcd,  0x00 0x00 0xd0 0x4c,    0x4c 0xd0 0x00 0x00,
//  0x33 0x03 0x00 0x00,   0x00 0x00 0x03 0x33,  0x00 0x00 0x30 0x33,    0x33 0x30 0x00 0x00,
//  0x9a 0x01 0x00 0x00,   0x00 0x00 0x01 0x9a,  0x00 0x00 0xa0 0x19,    0x19 0xa0 0x00 0x00,
//  0x66 0xfe 0xff 0xff,   0xff 0xff 0xfe 0x66,  0x00 0x00 0x60 0xe6,    0xe6 0x60 0x00 0x00,
//  0xcd 0xfc 0xff 0xff,   0xff 0xff 0xfc 0xcd,  0x00 0x00 0xd0 0xcc,    0xcc 0xd0 0x00 0x00,
//  0x33 0xfb 0xff 0xff,   0xff 0xff 0xfb 0x33,  0x00 0x00 0x30 0xb3,    0xb3 0x30 0x00 0x00,
//  0x9a 0xf9 0xff 0xff,   0xff 0xff 0xf9 0x9a,  0x00 0x00 0xa0 0x99,    0x99 0xa0 0x00 0x00,
//  0x00 0xf8 0xff 0xff,   0xff 0xff 0xf8 0x00,  0x00 0x00 0x00 0x80,    0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE16BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x07, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00,
		0x66, 0xfe, 0x00, 0x00,
		0xcd, 0xfc, 0x00, 0x00,
		0x33, 0xfb, 0x00, 0x00,
		0x9a, 0xf9, 0x00, 0x00,
		0x00, 0xf8, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE16BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0x00, 0x00,
		0x06, 0x66, 0x00, 0x00,
		0x04, 0xcd, 0x00, 0x00,
		0x03, 0x33, 0x00, 0x00,
		0x01, 0x9a, 0x00, 0x00,
		0xfe, 0x66, 0x00, 0x00,
		0xfc, 0xcd, 0x00, 0x00,
		0xfb, 0x33, 0x00, 0x00,
		0xf9, 0x9a, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE16BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0x7f, 0x00, 0x00,
		0x60, 0x66, 0x00, 0x00,
		0xd0, 0x4c, 0x00, 0x00,
		0x30, 0x33, 0x00, 0x00,
		0xa0, 0x19, 0x00, 0x00,
		0x60, 0xe6, 0x00, 0x00,
		0xd0, 0xcc, 0x00, 0x00,
		0x30, 0xb3, 0x00, 0x00,
		0xa0, 0x99, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE16BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xf0, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xfe, 0xff, 0x00, 0x00, 0x00,
		0xcd, 0xfc, 0xff, 0x00, 0x00, 0x00,
		0x33, 0xfb, 0xff, 0x00, 0x00, 0x00,
		0x9a, 0xf9, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xf8, 0xff, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x07, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0xfe, 0x66, 0x00, 0x00, 0x00,
		0xff, 0xfc, 0xcd, 0x00, 0x00, 0x00,
		0xff, 0xfb, 0x33, 0x00, 0x00, 0x00,
		0xff, 0xf9, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0xf8, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x60, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x30, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xfc, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xfb, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0xf9, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xf8, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfe, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xfb, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xf9, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 12-Bits Unsigned
//                               12LSB/8, 12MSB/8, 12LSB/16-LE, 12LSB/16-BE, 12MSB/16-LE, 12MSB/16-BE,
// 0x7fff -> 0x7ff + 0x800 = 0xfff, 0xff,    0xff,   0xff 0x0f,   0x0f 0xff,   0xf0 0xff,   0xff 0xf0,
// 0x6666 -> 0x666 + 0x800 = 0xe66, 0xe6,    0xe6,   0x66 0x0e,   0x0e 0x66,   0x60 0xe6,   0xe6 0x60,
// 0x4ccc -> 0x4cd + 0x800 = 0xccd, 0xcd,    0xcd,   0xcd 0x0c,   0x0c 0xcd,   0xd0 0xcc,   0xcc 0xd0,
// 0x3333 -> 0x333 + 0x800 = 0xb33, 0xb3,    0xb3,   0x33 0x0b,   0x0b 0x33,   0x30 0xb3,   0xb3 0x30,
// 0x1999 -> 0x19a + 0x800 = 0x99a, 0x9a     0x9a,   0x9a 0x09,   0x09 0x9a,   0xa0 0x99,   0x99 0xa0,
// 0xe666 -> 0xe66 - 0x800 = 0x666, 0x66,    0x66,   0x66 0x06,   0x06 0x66,   0x60 0x66,   0x66 0x60,
// 0xcccd -> 0xccd - 0x800 = 0x4cd, 0x4d,    0x4d,   0xcd 0x04,   0x04 0xcd,   0xd0 0x4c,   0x4c 0xd0,
// 0xb333 -> 0xb33 - 0x800 = 0x333, 0x33,    0x33,   0x33 0x03,   0x03 0x33,   0x30 0x33,   0x33 0x30,
// 0x999a -> 0x99a - 0x800 = 0x19a, 0x1a,    0x1a,   0x9a 0x01,   0x01 0x9a,   0xa0 0x19,   0x19 0xa0,
// 0x8000 -> 0x800 - 0x800 = 0x000, 0x00,    0x00,   0x00 0x00,   0x00 0x00,   0x00 0x00,   0x00 0x00,
//
//    12LSB/24-LE,     12LSB/24-BE,     12MSB/24-LE,     12MSB/24-BE,
// 0xff 0x0f 0x00,  0x00 0x0f 0xff,  0x00 0xf0 0xff,  0xff 0xf0 0x00,
// 0x66 0x0e 0x00,  0x00 0x0e 0x66,  0x00 0x60 0xe6,  0xe6 0x60 0x00,
// 0xcd 0x0c 0x00,  0x00 0x0c 0xcd,  0x00 0xd0 0xcc,  0xcc 0xd0 0x00,
// 0x33 0x0b 0x00,  0x00 0x0b 0x33,  0x00 0x30 0xb3,  0xb3 0x30 0x00,
// 0x9a 0x09 0x00,  0x00 0x09 0x9a,  0x00 0xa0 0x99,  0x99 0xa0 0x00,
// 0x66 0x06 0x00,  0x00 0x06 0x66,  0x00 0x60 0x66,  0x66 0x60 0x00,
// 0xcd 0x04 0x00,  0x00 0x04 0xcd,  0x00 0xd0 0x4c,  0x4c 0xd0 0x00,
// 0x33 0x03 0x00,  0x00 0x03 0x33,  0x00 0x30 0x33,  0x33 0x30 0x00,
// 0x9a 0x01 0x00,  0x00 0x01 0x9a,  0x00 0xa0 0x19,  0x19 0xa0 0x00,
// 0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,  0x00 0x00 0x00,
//
//         12LSB/32-LE,          12LSB/32-BE,          12MSB/32-LE,          12MSB/32-BE,
// 0xff 0x0f 0x00 0x00,  0x00 0x00 0x0f 0xff,  0x00 0x00 0xf0 0xff,  0xff 0xf0 0x00 0x00,
// 0x66 0x0e 0x00 0x00,  0x00 0x00 0x0e 0x66,  0x00 0x00 0x60 0xe6,  0xe6 0x60 0x00 0x00,
// 0xcd 0x0c 0x00 0x00,  0x00 0x00 0x0c 0xcd,  0x00 0x00 0xd0 0xcc,  0xcc 0xd0 0x00 0x00,
// 0x33 0x0b 0x00 0x00,  0x00 0x00 0x0b 0x33,  0x00 0x00 0x30 0xb3,  0xb3 0x30 0x00 0x00,
// 0x9a 0x09 0x00 0x00,  0x00 0x00 0x09 0x9a,  0x00 0x00 0xa0 0x99,  0x99 0xa0 0x00 0x00,
// 0x66 0x06 0x00 0x00,  0x00 0x00 0x06 0x66,  0x00 0x00 0x60 0x66,  0x66 0x60 0x00 0x00,
// 0xcd 0x04 0x00 0x00,  0x00 0x00 0x04 0xcd,  0x00 0x00 0xd0 0x4c,  0x4c 0xd0 0x00 0x00,
// 0x33 0x03 0x00 0x00,  0x00 0x00 0x03 0x33,  0x00 0x00 0x30 0x33,  0x33 0x30 0x00 0x00,
// 0x9a 0x01 0x00 0x00,  0x00 0x00 0x01 0x9a,  0x00 0x00 0xa0 0x19,  0x19 0xa0 0x00 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE16BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x0f, 0x00, 0x00,
		0x66, 0x0e, 0x00, 0x00,
		0xcd, 0x0c, 0x00, 0x00,
		0x33, 0x0b, 0x00, 0x00,
		0x9a, 0x09, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE16BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0x00, 0x00,
		0x0e, 0x66, 0x00, 0x00,
		0x0c, 0xcd, 0x00, 0x00,
		0x0b, 0x33, 0x00, 0x00,
		0x09, 0x9a, 0x00, 0x00,
		0x06, 0x66, 0x00, 0x00,
		0x04, 0xcd, 0x00, 0x00,
		0x03, 0x33, 0x00, 0x00,
		0x01, 0x9a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE16BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x00, 0x00,
		0x60, 0xe6, 0x00, 0x00,
		0xd0, 0xcc, 0x00, 0x00,
		0x30, 0xb3, 0x00, 0x00,
		0xa0, 0x99, 0x00, 0x00,
		0x60, 0x66, 0x00, 0x00,
		0xd0, 0x4c, 0x00, 0x00,
		0x30, 0x33, 0x00, 0x00,
		0xa0, 0x19, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE16BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0xf0, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x0e, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x0f, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x0e, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x0b, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x09, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x60, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x30, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0e, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0b, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x09, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xd0, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xa0, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo12BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 12;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput[10 * 2 * c_bytesPerSample] = {
		0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16A24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, c_expectOutput);
}

//-------------------------------------------------------------------------------------------
// 16-Bits Signed
//
// 0x7fff -> 0x7fff, 0x007fffff -> 0x7fff -> 0x7fff
// 0x6666 -> 0x6666, 0x00666666 -> 0x6666 -> 0x6666
// 0x4ccc -> 0x4ccc, 0x004ccccc -> 0x4ccd -> 0x4ccX
// 0x3333 -> 0x3333, 0x00333333 -> 0x3333 -> 0x3333
// 0x1999 -> 0x1999, 0x00199999 -> 0x199a -> 0x199X
// 0xe666 -> 0xe666, 0xffe66666 -> 0xe666 -> 0xe666
// 0xcccd -> 0xcccd, 0xffcccccd -> 0xcccd -> 0xcccd
// 0xb333 -> 0xb333, 0xffb33333 -> 0xb333 -> 0xb333
// 0x999a -> 0x999a, 0xff99999a -> 0x999a -> 0x999a
// 0x8000 -> 0x8000, 0xff800000 -> 0x8000 -> 0x8000
//
//           16LSB/8, 16MSB/8, 16LSB/16-LE, 16LSB/16-BE, 16MSB/16-LE, 16MSB/16-BE,
// 0x7fff ->    0x7f,    0x7f,   0xff 0x7f,   0x7f 0xff,   0xff 0x7f,   0x7f 0xff,
// 0x6666 ->    0x66,    0x66,   0x66 0x66,   0x66 0x66,   0x66 0x66,   0x66 0x66,
// 0x4ccX ->    0x4d,    0x4d,   0xcX 0x4c,   0x4c 0xcX,   0xcX 0x4c,   0x4c 0xcX,
// 0x3333 ->    0x33,    0x33,   0x33 0x33,   0x33 0x33,   0x33 0x33,   0x33 0x33,
// 0x199X ->    0x1a,    0x1a,   0x9X 0x19,   0x19 0x9X,   0x9X 0x19,   0x19 0x9X,
// 0xe666 ->    0xe6,    0xe6,   0x66 0xe6,   0xe6 0x66,   0x66 0xe6,   0xe6 0x66,
// 0xcccd ->    0xcd,    0xcd,   0xcd 0xcc,   0xcc 0xcd,   0xcd 0xcc,   0xcc 0xcd,
// 0xb333 ->    0xb3,    0xb3,   0x33 0xb3,   0xb3 0x33,   0x33 0xb3,   0xb3 0x33,
// 0x999a ->    0x9a,    0x9a,   0x9a 0x99,   0x99 0x9a,   0x9a 0x99,   0x99 0x9a,
// 0x8000 ->    0x80,    0x80,   0x00 0x80,   0x80 0x00,   0x00 0x80,   0x80 0x00,
//
//     16LSB/24-LE,      16LSB/24-BE,      16MSB/24-LE,      16MSB/24-BE,
//  0xff 0x7f 0x00,   0x00 0x7f 0xff,   0x00 0xff 0x7f,   0x7f 0xff 0x00,
//  0x66 0x66 0x00,   0x00 0x66 0x66,   0x00 0x66 0x66,   0x66 0x66 0x00,
//  0xcX 0x4c 0x00,   0x00 0x4c 0xcX,   0x00 0xcX 0x4c,   0x4c 0xcX 0x00,
//  0x33 0x33 0x00,   0x00 0x33 0x33,   0x00 0x33 0x33,   0x33 0x33 0x00,
//  0x9X 0x19 0x00,   0x00 0x19 0x9X,   0x00 0x9X 0x19,   0x19 0x9X 0x00,
//  0x66 0xe6 0xff,   0xff 0xe6 0x66,   0x00 0x66 0xe6,   0xe6 0x66 0x00,
//  0xcd 0xcc 0xff,   0xff 0xcc 0xcd,   0x00 0xcd 0xcc,   0xcc 0xcd 0x00,
//  0x33 0xb3 0xff,   0xff 0xb3 0x33,   0x00 0x33 0xb3,   0xb3 0x33 0x00,
//  0x9a 0x99 0xff,   0xff 0x99 0x9a,   0x00 0x9a 0x99,   0x99 0x9a 0x00,
//  0x00 0x80 0xff,   0xff 0x80 0x00,   0x00 0x00 0x80,   0x80 0x00 0x00,
// 
//         16LSB/32-LE,            16LSB/32-BE,          16MSB/32-LE,      16MSB/32-BE,
//  0xff 0x7f 0x00 0x00,   0x00 0x00 0x7f 0xff,   0x00 0x00 0xff 0x7f,   0x7f 0xff 0x00 0x00,
//  0x66 0x66 0x00 0x00,   0x00 0x00 0x66 0x66,   0x00 0x00 0x66 0x66,   0x66 0x66 0x00 0x00,
//  0xcX 0x4c 0x00 0x00,   0x00 0x00 0x4c 0xcX,   0x00 0x00 0xcX 0x4c,   0x4c 0xcX 0x00 0x00,
//  0x33 0x33 0x00 0x00,   0x00 0x00 0x33 0x33,   0x00 0x00 0x33 0x33,   0x33 0x33 0x00 0x00,
//  0x9X 0x19 0x00 0x00,   0x00 0x00 0x19 0x9X,   0x00 0x00 0x9X 0x19,   0x19 0x9X 0x00 0x00,
//  0x66 0xe6 0xff 0xff,   0xff 0xff 0xe6 0x66,   0x00 0x00 0x66 0xe6,   0xe6 0x66 0x00 0x00,
//  0xcd 0xcc 0xff 0xff,   0xff 0xff 0xcc 0xcd,   0x00 0x00 0xcd 0xcc,   0xcc 0xcd 0x00 0x00,
//  0x33 0xb3 0xff 0xff,   0xff 0xff 0xb3 0x33,   0x00 0x00 0x33 0xb3,   0xb3 0x33 0x00 0x00,
//  0x9a 0x99 0xff 0xff,   0xff 0xff 0x99 0x9a,   0x00 0x00 0x9a 0x99,   0x99 0x9a 0x00 0x00,
//  0x00 0x80 0xff 0xff,   0xff 0xff 0x80 0x00,   0x00 0x00 0x00 0x80,   0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

void testInt16Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect)
{
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tuint16 c_int16Samples[c_noSamples * c_noChannels] = {
		0x7fff, 0x1111,
		0x6666, 0x1111,
		0x4ccc, 0x1111,
		0x3333, 0x1111,
		0x1999, 0x1111,
		0xe666, 0x1111,
		0xcccd, 0x1111,
		0xb333, 0x1111,
		0x999a, 0x1111,
		0x8000, 0x1111,
	};
	
	int outputSize = c_noSamples * c_noChannels * bytesPerSample;
    tubyte *out = new tubyte [outputSize];
	
	SampleConverter sampleConverter(noBits, bytesPerSample, littleEndian, alignHigh, isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	if(isSigned)
	{
		EXPECT_EQ(FormatDescription::e_DataSignedInteger,sampleConverter.type());
	}
	else
	{
		EXPECT_EQ(FormatDescription::e_DataUnsignedInteger,sampleConverter.type());
	}
	
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(2,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(2,sampleConverter.numberOfOutputChannels());
	
	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int16Samples), out, c_noSamples, engine::e_SampleInt16);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));

	delete [] out;
}

//-------------------------------------------------------------------------------------------

void testInt24Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect)
{
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tuint32 c_int24Samples[c_noSamples * c_noChannels] = {
		0x007fffff, 0x00111111,
		0x00666666, 0x00111111,
		0x004ccccc, 0x00111111,
		0x00333333, 0x00111111,
		0x00199999, 0x00111111,
		0xffe66666, 0x00111111,
		0xffcccccd, 0x00111111,
		0xffb33333, 0x00111111,
		0xff99999a, 0x00111111,
		0xff800000, 0x00111111
	};
	
	int outputSize = c_noSamples * c_noChannels * bytesPerSample;
    tubyte *out = new tubyte [outputSize];
	
	SampleConverter sampleConverter(noBits, bytesPerSample, littleEndian, alignHigh, isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	if(isSigned)
	{
		EXPECT_EQ(FormatDescription::e_DataSignedInteger,sampleConverter.type());
	}
	else
	{
		EXPECT_EQ(FormatDescription::e_DataUnsignedInteger,sampleConverter.type());
	}
	
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(2,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(2,sampleConverter.numberOfOutputChannels());
	
	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int24Samples), out, c_noSamples, engine::e_SampleInt24);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

void testInt32Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect)
{
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tuint32 c_int32Samples[c_noSamples * c_noChannels] = {
		0x7fffffff, 0x11111111,
		0x66666666, 0x11111111,
		0x4ccccccc, 0x11111111,
		0x33333333, 0x11111111,
		0x19999999, 0x11111111,
		0xe6666666, 0x11111111,
		0xcccccccd, 0x11111111,
		0xb3333333, 0x11111111,
		0x9999999a, 0x11111111,
		0x80000000, 0x11111111
	};
	
	int outputSize = c_noSamples * c_noChannels * bytesPerSample;
    tubyte *out = new tubyte [outputSize];
	
	SampleConverter sampleConverter(noBits, bytesPerSample, littleEndian, alignHigh, isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	EXPECT_TRUE(sampleConverter.isSupported());
	EXPECT_FALSE(sampleConverter.isFloat());
	
	if(isSigned)
	{
		EXPECT_EQ(FormatDescription::e_DataSignedInteger,sampleConverter.type());
	}
	else
	{
		EXPECT_EQ(FormatDescription::e_DataUnsignedInteger,sampleConverter.type());
	}
	
	EXPECT_EQ(noBits,sampleConverter.bits());
	EXPECT_EQ(bytesPerSample,sampleConverter.bytesPerSample());
	EXPECT_EQ(littleEndian,sampleConverter.isLittleEndian());
	EXPECT_EQ(alignHigh,sampleConverter.isAlignedHigh());
	EXPECT_EQ(2,sampleConverter.numberOfInputChannels());
	EXPECT_EQ(2,sampleConverter.numberOfOutputChannels());
	
	memset(out, 0 , outputSize);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int32Samples), out, c_noSamples, engine::e_SampleInt32);
	EXPECT_EQ(0, memcmp(expect, out, outputSize));	
	
	delete [] out;
}

//-------------------------------------------------------------------------------------------

void testInt16Then24A32Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect16, const tubyte *expect24)
{
	testInt16Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect16);
	testInt24Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect24);
	testInt32Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect24);
}

//-------------------------------------------------------------------------------------------

void testInt16Then24Then32Convertion(tint noBits, tint bytesPerSample, bool littleEndian,
	bool alignHigh, bool isSigned, const tubyte *expect16, const tubyte *expect24, const tubyte *expect32)
{
	testInt16Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect16);
	testInt24Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect24);
	testInt32Convertion(noBits, bytesPerSample, littleEndian, alignHigh, isSigned, expect32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE16BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE16BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE16BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x00, 0x80, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE16BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0xff, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xff, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0xff, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x80, 0xff, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0xff, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xff, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0xff, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x80, 0xff, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x00, 0x00, 0x00,
		0xff, 0xe6, 0x66, 0x00, 0x00, 0x00,
		0xff, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xff, 0xb3, 0x33, 0x00, 0x00, 0x00,
		0xff, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0xe6, 0x66, 0x00, 0x00, 0x00,
		0xff, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xff, 0xb3, 0x33, 0x00, 0x00, 0x00,
		0xff, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x19, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------
// 16-Bits Unsigned
//
// 0x7fff + 0x8000 = 0xffff, 0x007fffff + 0x00800000 = 0x00ffffff -> 0xffff = 0xffff
// 0x6666 + 0x8000 = 0xe666, 0x00666666 + 0x00800000 = 0x00e66666 -> 0xe666 = 0xe666
// 0x4ccc + 0x8000 = 0xcccc, 0x004ccccc + 0x00800000 = 0x00cccccc -> 0xcccd = 0xcccX
// 0x3333 + 0x8000 = 0xb333, 0x00333333 + 0x00800000 = 0x00b33333 -> 0xb333 = 0xb333
// 0x1999 + 0x8000 = 0x9999, 0x00199999 + 0x00800000 = 0x00999999 -> 0x999a = 0x999X
// 0xe666 - 0x8000 = 0x6666, 0xffe66666 - 0x00800000 = 0x00666666 -> 0x6666 = 0x6666
// 0xcccd - 0x8000 = 0x4ccd, 0xffcccccd - 0x00800000 = 0x004ccccd -> 0x4ccd = 0x4ccd
// 0xb333 - 0x8000 = 0x3333, 0xffb33333 - 0x00800000 = 0x00333333 -> 0x3333 = 0x3333
// 0x999a - 0x8000 = 0x199a, 0xff99999a - 0x00800000 = 0x0019999a -> 0x199a = 0x199a
// 0x8000 - 0x8000 = 0x0000, 0xff800000 - 0x00800000 = 0x00000000 -> 0x0000 = 0x0000
//
//           16LSB/8, 16MSB/8, 16LSB/16-LE, 16LSB/16-BE, 16MSB/16-LE, 16MSB/16-BE,
// 0xffff ->    0xff,    0xff,   0xff 0xff,   0xff 0xff,   0xff 0xff,   0xff 0xff,
// 0xe666 ->    0xe6,    0xe6,   0x66 0xe6,   0xe6 0x66,   0x66 0xe6,   0xe6 0x66,
// 0xcccX ->    0xcd,    0xcd,   0xcX 0xcc,   0xcc 0xcX,   0xcX 0xcc,   0xcc 0xcX,
// 0xb333 ->    0xb3,    0xb3,   0x33 0xb3,   0xb3 0x33,   0x33 0xb3,   0xb3 0x33,
// 0x999X ->    0x9a,    0x9a,   0x9X 0x99,   0x99 0x9X,   0x9X 0x99,   0x99 0x9X,
// 0x6666 ->    0x66,    0x66,   0x66 0x66,   0x66 0x66,   0x66 0x66,   0x66 0x66,
// 0x4ccd ->    0x4d,    0x4d,   0xcd 0x4c,   0x4c 0xcd,   0xcd 0x4c,   0x4c 0xcd,
// 0x3333 ->    0x33,    0x33,   0x33 0x33,   0x33 0x33,   0x33 0x33,   0x33 0x33,
// 0x199a ->    0x1a,    0x1a,   0x9a 0x19,   0x19 0x1a,   0x9a 0x19,   0x19 0x1a,
// 0x0000 ->    0x00,    0x00,   0x00 0x00,   0x00 0x00,   0x00 0x00,   0x00 0x00,
//
//     16LSB/24-LE,      16LSB/24-BE,      16MSB/24-LE,      16MSB/24-BE,
//  0xff 0xff 0x00,   0x00 0xff 0xff,   0x00 0xff 0xff,   0xff 0xff 0x00,
//  0x66 0xe6 0x00,   0x00 0xe6 0x66,   0x00 0x66 0xe6,   0xe6 0x66 0x00,
//  0xcX 0xcc 0x00,   0x00 0xcc 0xcX,   0x00 0xcX 0xcc,   0xcc 0xcX 0x00,
//  0x33 0xb3 0x00,   0x00 0xb3 0x33,   0x00 0x33 0xb3,   0xb3 0x33 0x00,
//  0x9X 0x99 0x00,   0x00 0x99 0x9X,   0x00 0x9X 0x99,   0x99 0x9X 0x00,
//  0x66 0x66 0x00,   0x00 0x66 0x66,   0x00 0x66 0x66,   0x66 0x66 0x00,
//  0xcd 0x4c 0x00,   0x00 0x4c 0xcd,   0x00 0xcd 0x4c,   0x4c 0xcd 0x00,
//  0x33 0x33 0x00,   0x00 0x33 0x33,   0x00 0x33 0x33,   0x33 0x33 0x00,
//  0x9a 0x19 0x00,   0x00 0x19 0x1a,   0x00 0x9a 0x19,   0x19 0x1a 0x00,
//  0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,
// 
//         16LSB/32-LE,            16LSB/32-BE,          16MSB/32-LE,      16MSB/32-BE,
//  0xff 0xff 0x00 0x00,   0x00 0x00 0xff 0xff,   0x00 0x00 0xff 0xff,   0xff 0xff 0x00 0x00,
//  0x66 0xe6 0x00 0x00,   0x00 0x00 0xe6 0x66,   0x00 0x00 0x66 0xe6,   0xe6 0x66 0x00 0x00,
//  0xcX 0xcc 0x00 0x00,   0x00 0x00 0xcc 0xcX,   0x00 0x00 0xcX 0xcc,   0xcc 0xcX 0x00 0x00,
//  0x33 0xb3 0x00 0x00,   0x00 0x00 0xb3 0x33,   0x00 0x00 0x33 0xb3,   0xb3 0x33 0x00 0x00,
//  0x9X 0x99 0x00 0x00,   0x00 0x00 0x99 0x9X,   0x00 0x00 0x9X 0x99,   0x99 0x9X 0x00 0x00,
//  0x66 0x66 0x00 0x00,   0x00 0x00 0x66 0x66,   0x00 0x00 0x66 0x66,   0x66 0x66 0x00 0x00,
//  0xcd 0x4c 0x00 0x00,   0x00 0x00 0x4c 0xcd,   0x00 0x00 0xcd 0x4c,   0x4c 0xcd 0x00 0x00,
//  0x33 0x33 0x00 0x00,   0x00 0x00 0x33 0x33,   0x00 0x00 0x33 0x33,   0x33 0x33 0x00 0x00,
//  0x9a 0x19 0x00 0x00,   0x00 0x00 0x19 0x1a,   0x00 0x00 0x9a 0x19,   0x19 0x1a 0x00 0x00,
//  0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE16BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE16BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE16BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE16BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 2;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xe6, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0xb3, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0xe6, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0xb3, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo16BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 16;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------
// 20-Bits Signed
//
// 0x7fff -> 0x7fff0, 0x007fffff -> 0x7ffff -> 0x7fffX
// 0x6666 -> 0x66660, 0x00666666 -> 0x66666 -> 0x6666X
// 0x4ccc -> 0x4ccc0, 0x004ccccc -> 0x4cccd -> 0x4cccX
// 0x3333 -> 0x33330, 0x00333333 -> 0x33333 -> 0x3333X
// 0x1999 -> 0x19990, 0x00199999 -> 0x1999a -> 0x1999X
// 0xe666 -> 0xe6660, 0xffe66666 -> 0xe6666 -> 0xe666X
// 0xcccd -> 0xcccd0, 0xffcccccd -> 0xccccd -> 0xccccX
// 0xb333 -> 0xb3330, 0xffb33333 -> 0xb3333 -> 0xb333X
// 0x999a -> 0x999a0, 0xff99999a -> 0x9999a -> 0x9999X
// 0x8000 -> 0x80000, 0xff800000 -> 0x80000 -> 0x80000
//
//     20LSB/24-LE,      20LSB/24-BE,      20MSB/24-LE,      20MSB/24-BE,
//  0xfX 0xff 0x07,   0x07 0xff 0xfX,   0xX0 0xff 0x7f,   0x7f 0xff 0xX0,
//  0x6X 0x66 0x06,   0x06 0x66 0x6X,   0xX0 0x66 0x66,   0x66 0x66 0xX0,
//  0xcX 0xcc 0x04,   0x04 0xcc 0xcX,   0xX0 0xcc 0x4c,   0x4c 0xcc 0xX0,
//  0x3X 0x33 0x03,   0x03 0x33 0x3X,   0xX0 0x33 0x33,   0x33 0x33 0xX0,
//  0x9X 0x99 0x01,   0x01 0x99 0x9X,   0xX0 0x99 0x19,   0x19 0x99 0xX0,
//  0x6X 0x66 0xfe,   0xfe 0x66 0x6X,   0xX0 0x66 0xe6,   0xe6 0x66 0xX0,
//  0xcX 0xcc 0xfc,   0xfc 0xcc 0xcX,   0xX0 0xcc 0xcc,   0xcc 0xcc 0xX0,
//  0x3X 0x33 0xfb,   0xfb 0x33 0x3X,   0xX0 0x33 0xb3,   0xb3 0x33 0xX0,
//  0x9X 0x99 0xf9,   0xf9 0x99 0x9X,   0xX0 0x99 0x99,   0x99 0x99 0xX0,
//  0x00 0x00 0xf8,   0xf8 0x00 0x00,   0x00 0x00 0x80,   0x80 0x00 0xX0,
// 
//         20LSB/32-LE,            20LSB/32-BE,          20MSB/32-LE,      20MSB/32-BE,
//  0xfX 0xff 0x07 0x00,   0x00 0x07 0xff 0xfX,   0x00 0xX0 0xff 0x7f,   0x7f 0xff 0xX0 0x00,
//  0x6X 0x66 0x06 0x00,   0x00 0x06 0x66 0x6X,   0x00 0xX0 0x66 0x66,   0x66 0x66 0xX0 0x00,
//  0xcX 0xcc 0x04 0x00,   0x00 0x04 0xcc 0xcX,   0x00 0xX0 0xcc 0x4c,   0x4c 0xcc 0xX0 0x00,
//  0x3X 0x33 0x03 0x00,   0x00 0x03 0x33 0x3X,   0x00 0xX0 0x33 0x33,   0x33 0x33 0xX0 0x00,
//  0x9X 0x99 0x01 0x00,   0x00 0x01 0x99 0x9X,   0x00 0xX0 0x99 0x19,   0x19 0x99 0xX0 0x00,
//  0x6X 0x66 0xfe 0xff,   0xff 0xfe 0x66 0x6X,   0x00 0xX0 0x66 0xe6,   0xe6 0x66 0xX0 0x00,
//  0xcX 0xcc 0xfc 0xff,   0xff 0xfc 0xcc 0xcX,   0x00 0xX0 0xcc 0xcc,   0xcc 0xcc 0xX0 0x00,
//  0x3X 0x33 0xfb 0xff,   0xff 0xfb 0x33 0x3X,   0x00 0xX0 0x33 0xb3,   0xb3 0x33 0xX0 0x00,
//  0x9X 0x99 0xf9 0xff,   0xff 0xf9 0x99 0x9X,   0x00 0xX0 0x99 0x99,   0x99 0x99 0xX0 0x00,
//  0x00 0x00 0xf8 0xff,   0xff 0xf8 0x00 0x00,   0x00 0x00 0x00 0x80,   0x80 0x00 0xX0 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x07, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x06, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0x04, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x03, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x01, 0x00, 0x00, 0x00,
		0x60, 0x66, 0xfe, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xfc, 0x00, 0x00, 0x00,
		0x30, 0x33, 0xfb, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0xf9, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xf8, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x07, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x06, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x04, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x03, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x01, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xfe, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xfc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xfb, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xf9, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xf8, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0xf0, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x60, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xc0, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x90, 0x00, 0x00, 0x00,
		0xfe, 0x66, 0x60, 0x00, 0x00, 0x00,
		0xfc, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0xfb, 0x33, 0x30, 0x00, 0x00, 0x00,
		0xf9, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xfe, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xfc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xfb, 0x33, 0x33, 0x00, 0x00, 0x00,
		0xf9, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x60, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x30, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x60, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x19, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x60, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x99, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xfc, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0xf9, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xfc, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0xf9, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfe, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfb, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xf9, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x07, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfe, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xfb, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xf9, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------
// 20-Bits Unsigned
//
// 0x7fff + 0x8000 = 0xffff0, 0x007fffff + 0x00800000 = 0x00ffffff -> 0xfffff = 0xffffX
// 0x6666 + 0x8000 = 0xe6660, 0x00666666 + 0x00800000 = 0x00e66666 -> 0xe6666 = 0xe666X
// 0x4ccc + 0x8000 = 0xcccc0, 0x004ccccc + 0x00800000 = 0x00cccccc -> 0xccccd = 0xccccX
// 0x3333 + 0x8000 = 0xb3330, 0x00333333 + 0x00800000 = 0x00b33333 -> 0xb3333 = 0xb333X
// 0x1999 + 0x8000 = 0x99990, 0x00199999 + 0x00800000 = 0x00999999 -> 0x9999a = 0x9999X
// 0xe666 - 0x8000 = 0x66660, 0xffe66666 - 0x00800000 = 0x00666666 -> 0x66666 = 0x6666X
// 0xcccd - 0x8000 = 0x4ccd0, 0xffcccccd - 0x00800000 = 0x004ccccd -> 0x4cccd = 0x4cccX
// 0xb333 - 0x8000 = 0x33330, 0xffb33333 - 0x00800000 = 0x00333333 -> 0x33333 = 0x3333X
// 0x999a - 0x8000 = 0x199a0, 0xff99999a - 0x00800000 = 0x0019999a -> 0x1999a = 0x1999X
// 0x8000 - 0x8000 = 0x00000, 0xff800000 - 0x00800000 = 0x00000000 -> 0x00000 = 0x00000
//
//     20LSB/24-LE,      20LSB/24-BE,      20MSB/24-LE,      20MSB/24-BE,
//  0xfX 0xff 0x0f,   0x0f 0xff 0xfX,   0xX0 0xff 0xff,   0xff 0xff 0xX0,
//  0x6X 0x66 0x0e,   0x0e 0x66 0x6X,   0xX0 0x66 0xe6,   0xe6 0x66 0xX0,
//  0xcX 0xcc 0x0c,   0x0c 0xcc 0xcX,   0xX0 0xcc 0xcc,   0xcc 0xcc 0xX0,
//  0x3X 0x33 0x0b,   0x0b 0x33 0x3X,   0xX0 0x33 0xb3,   0xb3 0x33 0xX0,
//  0x9X 0x99 0x09,   0x09 0x99 0x9X,   0xX0 0x99 0x99,   0x99 0x99 0xX0,
//  0x6X 0x66 0x06,   0x06 0x66 0x6X,   0xX0 0x66 0x66,   0x66 0x66 0xX0,
//  0xcX 0xcc 0x04,   0x04 0xcc 0xcX,   0xX0 0xcc 0x4c,   0x4c 0xcc 0xX0,
//  0x3X 0x33 0x03,   0x03 0x33 0x3X,   0xX0 0x33 0x33,   0x33 0x33 0xX0,
//  0x9X 0x99 0x01,   0x01 0x99 0x9X,   0xX0 0x99 0x19,   0x19 0x99 0xX0,
//  0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,
// 
//         20LSB/32-LE,            20LSB/32-BE,          20MSB/32-LE,      20MSB/32-BE,
//  0xfX 0xff 0x0f 0x00,   0x00 0x07 0xff 0xfX,   0x00 0xX0 0xff 0xff,   0xff 0xff 0xX0 0x00,
//  0x6X 0x66 0x0e 0x00,   0x00 0x0e 0x66 0x6X,   0x00 0xX0 0x66 0xe6,   0xe6 0x66 0xX0 0x00,
//  0xcX 0xcc 0x0c 0x00,   0x00 0x0c 0xcc 0xcX,   0x00 0xX0 0xcc 0xcc,   0xcc 0xcc 0xX0 0x00,
//  0x3X 0x33 0x0b 0x00,   0x00 0x0b 0x33 0x3X,   0x00 0xX0 0x33 0xb3,   0xb3 0x33 0xX0 0x00,
//  0x9X 0x99 0x09 0x00,   0x00 0x09 0x99 0x9X,   0x00 0xX0 0x99 0x99,   0x99 0x99 0xX0 0x00,
//  0x6X 0x66 0x06 0x00,   0x00 0x06 0x66 0x6X,   0x00 0xX0 0x66 0x66,   0x66 0x66 0xX0 0x00,
//  0xcX 0xcc 0x04 0x00,   0x00 0x04 0xcc 0xcX,   0x00 0xX0 0xcc 0x4c,   0x4c 0xcc 0xX0 0x00,
//  0x3X 0x33 0x03 0x00,   0x00 0x03 0x33 0x3X,   0x00 0xX0 0x33 0x33,   0x33 0x33 0xX0 0x00,
//  0x9X 0x99 0x01 0x00,   0x00 0x01 0x99 0x9X,   0x00 0xX0 0x99 0x19,   0x19 0x99 0xX0 0x00,
//  0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x0e, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0x0c, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x0b, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x09, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x06, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0x04, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x03, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x0e, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x0c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x0b, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x09, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x06, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x04, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x03, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00,
		0x0e, 0x66, 0x60, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xc0, 0x00, 0x00, 0x00,
		0x0b, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x09, 0x99, 0x90, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x60, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x01, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x0e, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x0b, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x09, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x60, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x30, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xf0, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x60, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x99, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x60, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xd0, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x30, 0x00, 0x00, 0x00,
		0x19, 0x99, 0xa0, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0e, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0b, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x09, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0e, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0b, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x09, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x06, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x04, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x03, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo20BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 20;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
	testInt16Then24A32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24);
}

//-------------------------------------------------------------------------------------------
// 24-Bits Signed
//
// 0x7fff -> 0x7fff00, 0x007fffff -> 0x7fffff, 0x7fffffff -> 0x7fffff = 0x7fffXX (00, ff, ff)
// 0x6666 -> 0x666600, 0x00666666 -> 0x666666, 0x66666666 -> 0x666666 = 0x6666XX (00, 66, 66)
// 0x4ccc -> 0x4ccc00, 0x004ccccc -> 0x4ccccc, 0x4ccccccc -> 0x4ccccd = 0x4cccXX (00, cc, cd)
// 0x3333 -> 0x333300, 0x00333333 -> 0x333333, 0x33333333 -> 0x333333 = 0x3333XX (00, 33, 33)
// 0x1999 -> 0x199900, 0x00199999 -> 0x199999, 0x19999999 -> 0x19999a = 0x1999XX (00, 99, 9a)
// 0xe666 -> 0xe66600, 0xffe66666 -> 0xe66666, 0xe6666666 -> 0xe66666 = 0xe666XX (00, 66, 66)
// 0xcccd -> 0xcccd00, 0xffcccccd -> 0xcccccd, 0xcccccccd -> 0xcccccd = 0xcccXXX (d00, ccd, ccd)
// 0xb333 -> 0xb33300, 0xffb33333 -> 0xb33333, 0xb3333333 -> 0xb33333 = 0xb333XX (00, 33, 33)
// 0x999a -> 0x999a00, 0xff99999a -> 0x99999a, 0x9999999a -> 0x99999a = 0x999XXX (a00, 99a, 99a)
// 0x8000 -> 0x800000, 0xff800000 -> 0x800000, 0x80000000 -> 0x800000 = 0x800000
//
//     24LSB/24-LE,      24LSB/24-BE,      24MSB/24-LE,      24MSB/24-BE,
//  0xXX 0xff 0x7f,   0x7f 0xff 0xXX,   0xXX 0xff 0x7f,   0x7f 0xff 0xXX,
//  0xXX 0x66 0x66,   0x66 0x66 0xXX,   0xXX 0x66 0x66,   0x66 0x66 0xXX,
//  0xXX 0xcc 0x4c,   0x4c 0xcc 0xXX,   0xXX 0xcc 0x4c,   0x4c 0xcc 0xXX,
//  0xXX 0x33 0x33,   0x33 0x33 0xXX,   0xXX 0x33 0x33,   0x33 0x33 0xXX,
//  0xXX 0x99 0x19,   0x19 0x99 0xXX,   0xXX 0x99 0x19,   0x19 0x99 0xXX,
//  0xXX 0x66 0xe6,   0xe6 0x66 0xXX,   0xXX 0x66 0xe6,   0xe6 0x66 0xXX,
//  0xXX 0xcX 0xcc,   0xcc 0xcX 0xXX,   0xXX 0xcX 0xcc,   0xcc 0xcX 0xXX,
//  0xXX 0x33 0xb3,   0xb3 0x33 0xXX,   0xXX 0x33 0xb3,   0xb3 0x33 0xXX,
//  0xXX 0x9X 0x99,   0x99 0x9X 0xXX,   0xXX 0x9X 0x99,   0x99 0x9X 0xXX,
//  0x00 0x00 0x80,   0x80 0x00 0x00,   0x00 0x00 0x80,   0x80 0x00 0x00,
// 
//         24LSB/32-LE,            24LSB/32-BE,          24MSB/32-LE,      24MSB/32-BE,
//  0xXX 0xff 0x7f 0x00,   0x00 0x7f 0xff 0xXX,   0x00 0xXX 0xff 0x7f,   0x7f 0xff 0xXX 0x00,
//  0xXX 0x66 0x66 0x00,   0x00 0x66 0x66 0xXX,   0x00 0xXX 0x66 0x66,   0x66 0x66 0xXX 0x00,
//  0xXX 0xcc 0x4c 0x00,   0x00 0x4c 0xcc 0xXX,   0x00 0xXX 0xcc 0x4c,   0x4c 0xcc 0xXX 0x00,
//  0xXX 0x33 0x33 0x00,   0x00 0x33 0x33 0xXX,   0x00 0xXX 0x33 0x33,   0x33 0x33 0xXX 0x00,
//  0xXX 0x99 0x19 0x00,   0x00 0x19 0x99 0xXX,   0x00 0xXX 0x99 0x19,   0x19 0x99 0xXX 0x00,
//  0xXX 0x66 0xe6 0xff,   0xff 0xe6 0x66 0xXX,   0x00 0xXX 0x66 0xe6,   0xe6 0x66 0xXX 0x00,
//  0xXX 0xcX 0xcc 0xff,   0xff 0xcc 0xcX 0xXX,   0x00 0xXX 0xcX 0xcc,   0xcc 0xcX 0xXX 0x00,
//  0xXX 0x33 0xb3 0xff,   0xff 0xb3 0x33 0xXX,   0x00 0xXX 0x33 0xb3,   0xb3 0x33 0xXX 0x00,
//  0xXX 0x9X 0x99 0xff,   0xff 0x99 0x9X 0xXX,   0x00 0xXX 0x9X 0x99,   0x99 0x9X 0xXX 0x00,
//  0x00 0x00 0x80 0xff,   0xff 0x80 0x00 0x00,   0x00 0x00 0x00 0x80,   0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE24BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE24BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE24BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE24BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x00, 0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------
// 24-Bits Unsigned
//
// 0x7fff + 0x8000 = 0xffff00, 0x7fffff + 0x800000 = 0xffffff, 0x7fffffff + 0x80000000 = 0xffffff = 0xffffXX (00, ff, ff)
// 0x6666 + 0x8000 = 0xe66600, 0x666666 + 0x800000 = 0xe66666, 0x66666666 + 0x80000000 = 0xe66666 = 0xe666XX (00, 66, 66)
// 0x4ccc + 0x8000 = 0xcccc00, 0x4ccccc + 0x800000 = 0xcccccc, 0x4ccccccc + 0x80000000 = 0xcccccd = 0xccccXX (00, cc, cd)
// 0x3333 + 0x8000 = 0xb33300, 0x333333 + 0x800000 = 0xb33333, 0x33333333 + 0x80000000 = 0xb33333 = 0xb333XX (00, 33, 33)
// 0x1999 + 0x8000 = 0x999900, 0x199999 + 0x800000 = 0x999999, 0x19999999 + 0x80000000 = 0x99999a = 0x9999XX (00, 99, 9a)
// 0xe666 - 0x8000 = 0x666600, 0xe66666 - 0x800000 = 0x666666, 0xe6666666 - 0x80000000 = 0x666666 = 0x6666XX (00, 66, 66)
// 0xcccd - 0x8000 = 0x4ccd00, 0xcccccd - 0x800000 = 0x4ccccd, 0xcccccccd - 0x80000000 = 0x4ccccd = 0x4ccXXX (d00, ccd, ccd )
// 0xb333 - 0x8000 = 0x333300, 0xb33333 - 0x800000 = 0x333333, 0xb3333333 - 0x80000000 = 0x333333 = 0x3333XX (00, 33, 33)
// 0x999a - 0x8000 = 0x199a00, 0x99999a - 0x800000 = 0x19999a, 0x9999999a - 0x80000000 = 0x19999a = 0x199XXX (a00, 99a, 99a)
// 0x8000 - 0x8000 = 0x000000, 0x800000 - 0x800000 = 0x000000, 0x80000000 - 0x80000000 = 0x000000 = 0x000000
//
//     24LSB/24-LE,      24LSB/24-BE,      24MSB/24-LE,      24MSB/24-BE,
//  0xXX 0xff 0xff,   0xff 0xff 0xXX,   0xXX 0xff 0xff,   0xff 0xff 0xXX,
//  0xXX 0x66 0xe6,   0xe6 0x66 0xXX,   0xXX 0x66 0xe6,   0xe6 0x66 0xXX,
//  0xXX 0xcc 0xcc,   0xcc 0xcc 0xXX,   0xXX 0xcc 0xcc,   0xcc 0xcc 0xXX,
//  0xXX 0x33 0xb3,   0xb3 0x33 0xXX,   0xXX 0x33 0xb3,   0xb3 0x33 0xXX,
//  0xXX 0x99 0x99,   0x99 0x99 0xXX,   0xXX 0x99 0x99,   0x99 0x99 0xXX,
//  0xXX 0x66 0x66,   0x66 0x66 0xXX,   0xXX 0x66 0x66,   0x66 0x66 0xXX,
//  0xXX 0xcX 0x4c,   0x4c 0xcX 0xXX,   0xXX 0xcX 0x4c,   0x4c 0xcX 0xXX,
//  0xXX 0x33 0x33,   0x33 0x33 0xXX,   0xXX 0x33 0x33,   0x33 0x33 0xXX,
//  0xXX 0x9X 0x19,   0x19 0x9X 0xXX,   0xXX 0x9X 0x19,   0x19 0x9X 0xXX,
/// 0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,   0x00 0x00 0x00,
// 
//         24LSB/32-LE,            24LSB/32-BE,          24MSB/32-LE,      24MSB/32-BE,
//  0xXX 0xff 0xff 0x00,   0xff 0xff 0xXX 0x00,   0x00 0xXX 0xff 0xff,   0xff 0xff 0xXX 0x00,
//  0xXX 0x66 0xe6 0x00,   0xe6 0x66 0xXX 0x00,   0x00 0xXX 0x66 0xe6,   0xe6 0x66 0xXX 0x00,
//  0xXX 0xcc 0xcc 0x00,   0xcc 0xcc 0xXX 0x00,   0x00 0xXX 0xcc 0xcc,   0xcc 0xcc 0xXX 0x00,
//  0xXX 0x33 0xb3 0x00,   0xb3 0x33 0xXX 0x00,   0x00 0xXX 0x33 0xb3,   0xb3 0x33 0xXX 0x00,
//  0xXX 0x99 0x99 0x00,   0x99 0x99 0xXX 0x00,   0x00 0xXX 0x99 0x99,   0x99 0x99 0xXX 0x00,
//  0xXX 0x66 0x66 0x00,   0x66 0x66 0xXX 0x00,   0x00 0xXX 0x66 0x66,   0x66 0x66 0xXX 0x00,
//  0xXX 0xcX 0x4c 0x00,   0x4c 0xcX 0xXX 0x00,   0x00 0xXX 0xcX 0x4c,   0x4c 0xcX 0xXX 0x00,
//  0xXX 0x33 0x33 0x00,   0x33 0x33 0xXX 0x00,   0x00 0xXX 0x33 0x33,   0x33 0x33 0xXX 0x00,
//  0xXX 0x9X 0x19 0x00,   0x19 0x9X 0xXX 0x00,   0x00 0xXX 0x9X 0x19,   0x19 0x9X 0xXX 0x00,
/// 0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,   0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE24BitsLSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE24BitsLSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE24BitsMSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE24BitsMSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 3;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo24BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 24;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------
// 28-Bits signed
//
// 0x7fff = 0x07fff000, 0x7fffff = 0x07fffff0, 0x7fffffff = 0x07ffffff
// 0x6666 = 0x06666000, 0x666666 = 0x06666660, 0x66666666 = 0x06666666
// 0x4ccc = 0x04ccc000, 0x4ccccc = 0x04ccccc0, 0x4ccccccc = 0x04cccccd
// 0x3333 = 0x03333000, 0x333333 = 0x03333330, 0x33333333 = 0x03333333
// 0x1999 = 0x01999000, 0x199999 = 0x01999990, 0x19999999 = 0x0199999a
// 0xe666 = 0xfe666000, 0xe66666 = 0xfe666660, 0xe6666666 = 0xfe666666
// 0xcccd = 0xfcccd000, 0xcccccd = 0xfcccccd0, 0xcccccccd = 0xfccccccd
// 0xb333 = 0xfb333000, 0xb33333 = 0xfb333330, 0xb3333333 = 0xfb333333
// 0x999a = 0xf999a000, 0x99999a = 0xf99999a0, 0x9999999a = 0xf999999a
// 0x8000 = 0xf8000000, 0x800000 = 0xf8000000, 0x80000000 = 0xf8000000
//
//      16-28LSB/32-LE,       16-28LSB/32-BE,       16-28MSB/32-LE,       16-28MSB/32-BE,
// 0x00 0xf0 0xff 0x07,  0x07 0xff 0xf0 0x00,  0x00 0x00 0xff 0x7f,  0x7f 0xff 0x00 0x00,
// 0x00 0x60 0x66 0x06,  0x06 0x66 0x60 0x00,  0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,
// 0x00 0xc0 0xcc 0x04,  0x04 0xcc 0xc0 0x00,  0x00 0x00 0xcc 0x4c,  0x4c 0xcc 0x00 0x00,
// 0x00 0x30 0x33 0x03,  0x03 0x33 0x30 0x00,  0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,
// 0x00 0x90 0x99 0x01,  0x01 0x99 0x90 0x00,  0x00 0x00 0x99 0x19,  0x19 0x99 0x00 0x00,
// 0x00 0x60 0x66 0xfe,  0xfe 0x66 0x60 0x00,  0x00 0x00 0x66 0xe6,  0xfe 0x66 0x00 0x00,
// 0x00 0xd0 0xcc 0xfc,  0xfc 0xcc 0xd0 0x00,  0x00 0x00 0xcd 0xcc,  0xcc 0xcd 0x00 0x00,
// 0x00 0x30 0x33 0xfb,  0xfb 0x33 0x30 0x00,  0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,
// 0x00 0xa0 0x99 0xf9,  0xf9 0x99 0xa0 0x00,  0x00 0x00 0x9a 0x99,  0x99 0x9a 0x00 0x00,
// 0x00 0x00 0x00 0xf8,  0xf8 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//
//      24-28LSB/32-LE,       24-28LSB/32-BE,       24-28MSB/32-LE,       24-28MSB/32-BE,
// 0xf0 0xff 0xff 0x07,  0x07 0xff 0xff 0xf0,  0x00 0xff 0xff 0x7f,  0x7f 0xff 0xff 0x00,
// 0x60 0x66 0x66 0x06,  0x06 0x66 0x66 0x60,  0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,
// 0xc0 0xcc 0xcc 0x04,  0x04 0xcc 0xcc 0xc0,  0x00 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0x00,
// 0x30 0x33 0x33 0x03,  0x03 0x33 0x33 0x30,  0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,
// 0x90 0x99 0x99 0x01,  0x01 0x99 0x99 0x90,  0x00 0x99 0x99 0x19,  0x19 0x99 0x99 0x00,
// 0x60 0x66 0x66 0xfe,  0xfe 0x66 0x66 0x60,  0x00 0x66 0x66 0xe6,  0xfe 0x66 0x66 0x00,
// 0xd0 0xcc 0xcc 0xfc,  0xfc 0xcc 0xcd 0xd0,  0x00 0xcd 0xcc 0xcc,  0xcc 0xcc 0xcd 0x00,
// 0x30 0x33 0x33 0xfb,  0xfb 0x33 0x33 0x30,  0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,
// 0xa0 0x99 0x99 0xf9,  0xf9 0x99 0x99 0xa0,  0x00 0x9a 0x99 0x99,  0x99 0x99 0x9a 0x00,
// 0x00 0x00 0x00 0xf8,  0xf8 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//
//      32-28LSB/32-LE,       32-28LSB/32-BE,       32-28MSB/32-LE,       32-28MSB/32-BE,
// 0xff 0xff 0xff 0x07,  0x07 0xff 0xff 0xff,  0xf0 0xff 0xff 0x7f,  0x7f 0xff 0xff 0xf0,
// 0x66 0x66 0x66 0x06,  0x06 0x66 0x66 0x66,  0x60 0x66 0x66 0x66,  0x66 0x66 0x66 0x60,
// 0xcd 0xcc 0xcc 0x04,  0x04 0xcc 0xcc 0xcd,  0xd0 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xd0,
// 0x33 0x33 0x33 0x03,  0x03 0x33 0x33 0x33,  0x30 0x33 0x33 0x33,  0x33 0x33 0x33 0x30,
// 0x9a 0x99 0x99 0x01,  0x01 0x99 0x99 0x9a,  0xa0 0x99 0x99 0x19,  0x19 0x99 0x99 0xa0,
// 0x66 0x66 0x66 0xfe,  0xfe 0x66 0x66 0x66,  0x60 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x60,
// 0xcd 0xcc 0xcc 0xfc,  0xfc 0xcc 0xcc 0xcd,  0xd0 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xd0,
// 0x33 0x33 0x33 0xfb,  0xfb 0x33 0x33 0x33,  0x30 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x30,
// 0x9a 0x99 0x99 0xf9,  0xf9 0x99 0x99 0x9a,  0xa0 0x99 0x99 0x99,  0x99 0x99 0x99 0xa0,
// 0x00 0x00 0x00 0xf8,  0xf8 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xc0, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x90, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0xfc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0xfb, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0xf9, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0xfc, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0xfb, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0xf9, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xfc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xfb, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0xf9, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfb, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf9, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xfc, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xfb, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0xf9, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xfc, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xfb, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xf9, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------
// 28-Bits Unsigned
//
// 0x7fff + 0x8000 = 0x0ffff000, 0x7fffff + 0x800000 = 0x0ffffff0, 0x7fffffff + 0x80000000 = 0x0fffffff
// 0x6666 + 0x8000 = 0x0e666000, 0x666666 + 0x800000 = 0x0e666660, 0x66666666 + 0x80000000 = 0x0e666666
// 0x4ccc + 0x8000 = 0x0cccc000, 0x4ccccc + 0x800000 = 0x0cccccc0, 0x4ccccccc + 0x80000000 = 0x0ccccccd
// 0x3333 + 0x8000 = 0x0b333000, 0x333333 + 0x800000 = 0x0b333330, 0x33333333 + 0x80000000 = 0x0b333333
// 0x1999 + 0x8000 = 0x09999000, 0x199999 + 0x800000 = 0x09999990, 0x19999999 + 0x80000000 = 0x0999999a
// 0xe666 - 0x8000 = 0x06666000, 0xe66666 - 0x800000 = 0x06666660, 0xe6666666 - 0x80000000 = 0x06666666
// 0xcccd - 0x8000 = 0x04ccd000, 0xcccccd - 0x800000 = 0x04ccccd0, 0xcccccccd - 0x80000000 = 0x04cccccd
// 0xb333 - 0x8000 = 0x03333000, 0xb33333 - 0x800000 = 0x03333330, 0xb3333333 - 0x80000000 = 0x03333333
// 0x999a - 0x8000 = 0x0199a000, 0x99999a - 0x800000 = 0x019999a0, 0x9999999a - 0x80000000 = 0x0199999a
// 0x8000 - 0x8000 = 0x00000000, 0x800000 - 0x800000 = 0x00000000, 0x80000000 - 0x80000000 = 0x00000000
//
//      16-28LSB/32-LE,       16-28LSB/32-BE,       16-28MSB/32-LE,       16-28MSB/32-BE,
// 0x00 0xf0 0xff 0x0f,  0x0f 0xff 0xf0 0x00,  0x00 0x00 0xff 0xff,  0xff 0xff 0x00 0x00,
// 0x00 0x60 0x66 0x0e,  0x0e 0x66 0x60 0x00,  0x00 0x00 0x66 0xe6,  0xe6 0x66 0x00 0x00,
// 0x00 0xc0 0xcc 0x0c,  0x0c 0xcc 0xc0 0x00,  0x00 0x00 0xcc 0xcc,  0xcc 0xcc 0x00 0x00,
// 0x00 0x30 0x33 0x0b,  0x0b 0x33 0x30 0x00,  0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,
// 0x00 0x90 0x99 0x09,  0x09 0x99 0x90 0x00,  0x00 0x00 0x99 0x99,  0x99 0x99 0x00 0x00,
// 0x00 0x60 0x66 0x06,  0x06 0x66 0x60 0x00,  0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,
// 0x00 0xd0 0xcc 0x04,  0x04 0xcc 0xd0 0x00,  0x00 0x00 0xcd 0x4c,  0x4c 0xcd 0x00 0x00,
// 0x00 0x30 0x33 0x03,  0x03 0x33 0x30 0x00,  0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,
// 0x00 0xa0 0x99 0x01,  0x01 0x99 0xa0 0x00,  0x00 0x00 0x9a 0x19,  0x19 0x9a 0x00 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//
//      24-28LSB/32-LE,       24-28LSB/32-BE,       24-28MSB/32-LE,       24-28MSB/32-BE,
// 0xf0 0xff 0xff 0x0f,  0x0f 0xff 0xff 0xf0,  0x00 0xff 0xff 0xff,  0xff 0xff 0xff 0x00,
// 0x60 0x66 0x66 0x0e,  0x0e 0x66 0x66 0x60,  0x00 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x00,
// 0xc0 0xcc 0xcc 0x0c,  0x0c 0xcc 0xcc 0xc0,  0x00 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0x00,
// 0x30 0x33 0x33 0x0b,  0x0b 0x33 0x33 0x30,  0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,
// 0x90 0x99 0x99 0x09,  0x09 0x99 0x99 0x90,  0x00 0x99 0x99 0x99,  0x99 0x99 0x99 0x00,
// 0x60 0x66 0x66 0x06,  0x06 0x66 0x66 0x60,  0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,
// 0xd0 0xcc 0xcc 0x04,  0x04 0xcc 0xcd 0xd0,  0x00 0xcd 0xcc 0x4c,  0x4c 0xcc 0xcd 0x00,
// 0x30 0x33 0x33 0x03,  0x03 0x33 0x33 0x30,  0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,
// 0xa0 0x99 0x99 0x01,  0x01 0x99 0x99 0xa0,  0x00 0x9a 0x99 0x19,  0x19 0x99 0x9a 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x00 0x00 0x00 0x00,
//
//      32-28LSB/32-LE,       32-28LSB/32-BE,       32-28MSB/32-LE,       32-28MSB/32-BE,
// 0xff 0xff 0xff 0x0f,  0x0f 0xff 0xff 0xff,  0xf0 0xff 0xff 0xff,  0xff 0xff 0xff 0xf0,
// 0x66 0x66 0x66 0x0e,  0x0e 0x66 0x66 0x66,  0x60 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x60,
// 0xcd 0xcc 0xcc 0x0c,  0x0c 0xcc 0xcc 0xcd,  0xd0 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xd0,
// 0x33 0x33 0x33 0x0b,  0x0b 0x33 0x33 0x33,  0x30 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x30,
// 0x9a 0x99 0x99 0x09,  0x09 0x99 0x99 0x9a,  0xa0 0x99 0x99 0x99,  0x99 0x99 0x99 0xa0,
// 0x66 0x66 0x66 0x06,  0x06 0x66 0x66 0x66,  0x60 0x66 0x66 0x66,  0x66 0x66 0x66 0x60,
// 0xcd 0xcc 0xcc 0x04,  0x04 0xcc 0xcc 0xcd,  0xd0 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xd0,
// 0x33 0x33 0x33 0x03,  0x03 0x33 0x33 0x33,  0x30 0x33 0x33 0x33,  0x33 0x33 0x33 0x30,
// 0x9a 0x99 0x99 0x01,  0x01 0x99 0x99 0x9a,  0xa0 0x99 0x99 0x19,  0x19 0x99 0x99 0xa0,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x0e, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xc0, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x90, 0x99, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xd0, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x30, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xa0, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x0e, 0x00, 0x00, 0x00, 0x00,
		0xc0, 0xcc, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x90, 0x99, 0x99, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x0e, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x0b, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x06, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0e, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0b, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x09, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x0e, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xcc, 0xc0, 0x00, 0x00, 0x00, 0x00,
		0x0b, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x09, 0x99, 0x99, 0x90, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x0e, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x0c, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x0b, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x09, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x04, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xf0, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x60, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xd0, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x30, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xa0, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo28BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 28;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x60, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xd0, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0xa0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------
// 32-Bits Signed
//
// 0x7fff = 0x7fff0000, 0x7fffff = 0x7fffff00, 0x7fffffff
// 0x6666 = 0x66660000, 0x666666 = 0x66666600, 0x66666666
// 0x4ccc = 0x4ccc0000, 0x4ccccc = 0x4ccccc00, 0x4ccccccc
// 0x3333 = 0x33330000, 0x333333 = 0x33333300, 0x33333333
// 0x1999 = 0x19990000, 0x199999 = 0x19999900, 0x19999999
// 0xe666 = 0xe6660000, 0xe66666 = 0xe6666600, 0xe6666666
// 0xcccd = 0xcccd0000, 0xcccccd = 0xcccccd00, 0xcccccccd
// 0xb333 = 0xb3330000, 0xb33333 = 0xb3333300, 0xb3333333
// 0x999a = 0x999a0000, 0x99999a = 0x99999a00, 0x9999999a
// 0x8000 = 0x80000000, 0x800000 = 0x80000000, 0x80000000
//
//      16-32LSB/32-LE,       16-32LSB/32-BE,       16-32MSB/32-LE,       16-32MSB/32-BE,
// 0x00 0x00 0xff 0x7f,  0x7f 0xff 0x00 0x00,  0x00 0x00 0xff 0x7f,  0x7f 0xff 0x00 0x00,
// 0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,  0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,
// 0x00 0x00 0xcc 0x4c,  0x4c 0xcc 0x00 0x00,  0x00 0x00 0xcc 0x4c,  0x4c 0xcc 0x00 0x00,
// 0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,  0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,
// 0x00 0x00 0x99 0x19,  0x19 0x99 0x00 0x00,  0x00 0x00 0x99 0x19,  0x19 0x99 0x00 0x00,
// 0x00 0x00 0x66 0xe6,  0xe6 0x66 0x00 0x00,  0x00 0x00 0x66 0xe6,  0xe6 0x66 0x00 0x00,
// 0x00 0x00 0xcd 0xcc,  0xcc 0xcd 0x00 0x00,  0x00 0x00 0xcd 0xcc,  0xcc 0xcd 0x00 0x00,
// 0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,  0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,
// 0x00 0x00 0x9a 0x99,  0x99 0x9a 0x00 0x00,  0x00 0x00 0x9a 0x99,  0x99 0x9a 0x00 0x00,
// 0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//
//      24-32LSB/32-LE,       24-32LSB/32-BE,       24-32MSB/32-LE,       24-32MSB/32-BE,
// 0x00 0xff 0xff 0x7f,  0x7f 0xff 0xff 0x00,  0x00 0xff 0xff 0x7f,  0x7f 0xff 0xff 0x00,
// 0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,  0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,
// 0x00 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0x00,  0x00 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0x00,
// 0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,  0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,
// 0x00 0x99 0x99 0x19,  0x19 0x99 0x99 0x00,  0x00 0x99 0x99 0x19,  0x19 0x99 0x99 0x00,
// 0x00 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x00,  0x00 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x00,
// 0x00 0xcd 0xcc 0xcc,  0xcc 0xcc 0xcd 0x00,  0x00 0xcd 0xcc 0xcc,  0xcc 0xcc 0xcd 0x00,
// 0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,  0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,
// 0x00 0x9a 0x99 0x99,  0x99 0x99 0x9a 0x00,  0x00 0x9a 0x99 0x99,  0x99 0x99 0x9a 0x00,
// 0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//
//      32-32LSB/32-LE,       32-32LSB/32-BE,       32-32MSB/32-LE,       32-32MSB/32-BE,
// 0xff 0xff 0xff 0x7f,  0x7f 0xff 0xff 0xff,  0xff 0xff 0xff 0x7f,  0x7f 0xff 0xff 0xff,
// 0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,
// 0xcc 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xcc,
// 0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,
// 0x99 0x99 0x99 0x19,  0x19 0x99 0x99 0x99,  0x99 0x99 0x99 0x19,  0x19 0x99 0x99 0x99,
// 0x66 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x66,  0x66 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x66,
// 0xcd 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xcd,  0xcd 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xcd,
// 0x33 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x33,  0x33 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x33,
// 0x9a 0x99 0x99 0x99,  0x99 0x99 0x99 0x9a,  0x9a 0x99 0x99 0x99,  0x99 0x99 0x99 0x9a,
// 0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,  0x00 0x00 0x00 0x80,  0x80 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInLE32BitsLSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInBE32BitsLSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInLE32BitsMSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInBE32BitsMSB)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------
// 32-Bits Unsigned
//
// 0x7fff + 0x8000 = 0xffff0000, 0x7fffff + 0x800000 = 0xffffff00, 0x7fffffff + 0x80000000 = 0xffffffff
// 0x6666 + 0x8000 = 0xe6660000, 0x666666 + 0x800000 = 0xe6666600, 0x66666666 + 0x80000000 = 0xe6666666
// 0x4ccc + 0x8000 = 0xcccc0000, 0x4ccccc + 0x800000 = 0xcccccc00, 0x4ccccccc + 0x80000000 = 0xcccccccc
// 0x3333 + 0x8000 = 0xb3330000, 0x333333 + 0x800000 = 0xb3333300, 0x33333333 + 0x80000000 = 0xb3333333
// 0x1999 + 0x8000 = 0x99990000, 0x199999 + 0x800000 = 0x99999900, 0x19999999 + 0x80000000 = 0x99999999
// 0xe666 - 0x8000 = 0x66660000, 0xe66666 - 0x800000 = 0x66666600, 0xe6666666 - 0x80000000 = 0x66666666
// 0xcccd - 0x8000 = 0x4ccd0000, 0xcccccd - 0x800000 = 0x4ccccd00, 0xcccccccd - 0x80000000 = 0x4ccccccd
// 0xb333 - 0x8000 = 0x33330000, 0xb33333 - 0x800000 = 0x33333300, 0xb3333333 - 0x80000000 = 0x33333333
// 0x999a - 0x8000 = 0x199a0000, 0x99999a - 0x800000 = 0x19999a00, 0x9999999a - 0x80000000 = 0x1999999a
// 0x8000 - 0x8000 = 0x00000000, 0x800000 - 0x800000 = 0x00000000, 0x80000000 - 0x80000000 = 0x00000000
//
//      16-32LSB/32-LE,       16-32LSB/32-BE,       16-32MSB/32-LE,       16-32MSB/32-BE,
// 0x00 0x00 0xff 0xff,  0xff 0xff 0x00 0x00,  0x00 0x00 0xff 0xff,  0xff 0xff 0x00 0x00,
// 0x00 0x00 0x66 0xe6,  0xe6 0x66 0x00 0x00,  0x00 0x00 0x66 0xe6,  0xe6 0x66 0x00 0x00,
// 0x00 0x00 0xcc 0xcc,  0xcc 0xcc 0x00 0x00,  0x00 0x00 0xcc 0xcc,  0xcc 0xcc 0x00 0x00,
// 0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,  0x00 0x00 0x33 0xb3,  0xb3 0x33 0x00 0x00,
// 0x00 0x00 0x99 0x99,  0x99 0x99 0x00 0x00,  0x00 0x00 0x99 0x99,  0x99 0x99 0x00 0x00,
// 0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,  0x00 0x00 0x66 0x66,  0x66 0x66 0x00 0x00,
// 0x00 0x00 0xcd 0x4c,  0x4c 0xcd 0x00 0x00,  0x00 0x00 0xcd 0x4c,  0x4c 0xcd 0x00 0x00,
// 0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,  0x00 0x00 0x33 0x33,  0x33 0x33 0x00 0x00,
// 0x00 0x00 0x9a 0x19,  0x19 0x9a 0x00 0x00,  0x00 0x00 0x9a 0x19,  0x19 0x9a 0x00 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//
//      24-32LSB/32-LE,       24-32LSB/32-BE,       24-32MSB/32-LE,       24-32MSB/32-BE,
// 0x00 0xff 0xff 0xff,  0xff 0xff 0xff 0x00,  0x00 0xff 0xff 0xff,  0xff 0xff 0xff 0x00,
// 0x00 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x00,  0x00 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x00,
// 0x00 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0x00,  0x00 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0x00,
// 0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,  0x00 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x00,
// 0x00 0x99 0x99 0x99,  0x99 0x99 0x99 0x00,  0x00 0x99 0x99 0x99,  0x99 0x99 0x99 0x00,
// 0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,  0x00 0x66 0x66 0x66,  0x66 0x66 0x66 0x00,
// 0x00 0xcd 0xcc 0x4c,  0x4c 0xcc 0xcd 0x00,  0x00 0xcd 0xcc 0x4c,  0x4c 0xcc 0xcd 0x00,
// 0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,  0x00 0x33 0x33 0x33,  0x33 0x33 0x33 0x00,
// 0x00 0x9a 0x99 0x19,  0x19 0x99 0x9a 0x00,  0x00 0x9a 0x99 0x19,  0x19 0x99 0x9a 0x00,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//
//      32-32LSB/32-LE,       32-32LSB/32-BE,       32-32MSB/32-LE,       32-32MSB/32-BE,
// 0xff 0xff 0xff 0xff,  0xff 0xff 0xff 0xff,  0xff 0xff 0xff 0xff,  0xff 0xff 0xff 0xff,
// 0x66 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x66,  0x66 0x66 0x66 0xe6,  0xe6 0x66 0x66 0x66,
// 0xcc 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xcc,  0xcc 0xcc 0xcc 0xcc,
// 0x33 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x33,  0x33 0x33 0x33 0xb3,  0xb3 0x33 0x33 0x33,
// 0x99 0x99 0x99 0x99,  0x99 0x99 0x99 0x99,  0x99 0x99 0x99 0x99,  0x99 0x99 0x99 0x99,
// 0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,  0x66 0x66 0x66 0x66,
// 0xcd 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xcd,  0xcd 0xcc 0xcc 0x4c,  0x4c 0xcc 0xcc 0xcd,
// 0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,  0x33 0x33 0x33 0x33,
// 0x9a 0x99 0x99 0x19,  0x19 0x99 0x99 0x9a,  0x9a 0x99 0x99 0x19,  0x19 0x99 0x99 0x9a,
// 0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,  0x00 0x00 0x00 0x00,
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInLE32BitsLSBUnsigned)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInBE32BitsLSBUnsigned)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInLE32BitsMSBUnsigned)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0x4c, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,int16A24A32SamplesTo32BitSampleInBE32BitsMSBUnsigned)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = true;
	const bool c_isSigned = false;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	
	const tubyte c_expectOutput16[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput24[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	const tubyte c_expectOutput32[10 * 2 * c_bytesPerSample] = {
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xe6, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0xb3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x4c, 0xcc, 0xcc, 0xcd, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x9a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	testInt16Then24Then32Convertion(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned, 
		c_expectOutput16, c_expectOutput24, c_expectOutput32);
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,convertAtIndexInt16)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tuint16 c_int16Samples[c_noSamples * c_noChannels] = {
		0x7fff, 0x1111,
		0x6666, 0x1111,
		0x4ccc, 0x1111,
		0x3333, 0x1111,
		0x1999, 0x1111,
		0xe666, 0x1111,
		0xcccd, 0x1111,
		0xb333, 0x1111,
		0x999a, 0x1111,
		0x8000, 0x1111,
	};
	
	const tubyte c_expectOutput16[7 * c_noChannels * c_bytesPerSample] = {
		0x00, 0x00, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xcd, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x9a, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	tint iIdx = 3 * c_noChannels;
	tint outputSize = 7 * c_noChannels * c_bytesPerSample;
	tubyte out[7 * c_noChannels * c_bytesPerSample];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	memset(out, 0, outputSize);
	sampleConverter.convertAtIndex(reinterpret_cast<const sample_t *>(c_int16Samples), iIdx, out, 7, engine::e_SampleInt16);
	EXPECT_EQ(0, memcmp(c_expectOutput16, out, outputSize));
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,convertAtIndexInt24)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tuint32 c_int24Samples[c_noSamples * c_noChannels] = {
		0x007fffff, 0x00111111,
		0x00666666, 0x00111111,
		0x004ccccc, 0x00111111,
		0x00333333, 0x00111111,
		0x00199999, 0x00111111,
		0xffe66666, 0x00111111,
		0xffcccccd, 0x00111111,
		0xffb33333, 0x00111111,
		0xff99999a, 0x00111111,
		0xff800000, 0x00111111
	};

	const tubyte c_expectOutput24[7 * c_noChannels * c_bytesPerSample] = {
		0x00, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xcd, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x9a, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	tint iIdx = 3 * c_noChannels;
	tint outputSize = 7 * c_noChannels * c_bytesPerSample;
	tubyte out[7 * c_noChannels * c_bytesPerSample];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	memset(out, 0, outputSize);
	sampleConverter.convertAtIndex(reinterpret_cast<const sample_t *>(c_int24Samples), iIdx, out, 7, engine::e_SampleInt24);
	EXPECT_EQ(0, memcmp(c_expectOutput24, out, outputSize));
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,convertAtIndexInt32)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

	const tuint32 c_int32Samples[c_noSamples * c_noChannels] = {
		0x7fffffff, 0x11111111,
		0x66666666, 0x11111111,
		0x4ccccccc, 0x11111111,
		0x33333333, 0x11111111,
		0x19999999, 0x11111111,
		0xe6666666, 0x11111111,
		0xcccccccd, 0x11111111,
		0xb3333333, 0x11111111,
		0x9999999a, 0x11111111,
		0x80000000, 0x11111111
	};

	const tubyte c_expectOutput32[7 * c_noChannels * c_bytesPerSample] = {
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};
	
	tint iIdx = 3 * c_noChannels;
	tint outputSize = 7 * c_noChannels * c_bytesPerSample;
	tubyte out[7 * c_noChannels * c_bytesPerSample];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	memset(out, 0, outputSize);
	sampleConverter.convertAtIndex(reinterpret_cast<const sample_t *>(c_int32Samples), iIdx, out, 7, engine::e_SampleInt32);
	EXPECT_EQ(0, memcmp(c_expectOutput32, out, outputSize));
}

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,convertAtIndexFloat)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = true;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;

#if defined(SINGLE_FLOAT_SAMPLE)
	const sample_t c_sampleInput[c_noSamples * c_noChannels] = {
		 1.0f, 1.0f,
		 0.8f, 1.0f,
		 0.6f, 1.0f,
		 0.4f, 1.0f,
		 0.2f, 1.0f,
		-0.2f, 1.0f,
		-0.4f, 1.0f,
		-0.6f, 1.0f,
		-0.8f, 1.0f,
		-1.0f, 1.0f
	};
#else
	const sample_t c_sampleInput[c_noSamples * c_noChannels] = {
		 1.0, 1.0,
		 0.8, 1.0,
		 0.6, 1.0,
		 0.4, 1.0,
		 0.2, 1.0,
		-0.2, 1.0,
		-0.4, 1.0,
		-0.6, 1.0,
		-0.8, 1.0,
		-1.0, 1.0
	};
#endif
	
	const tubyte c_expectOutput[7 * c_noChannels * c_bytesPerSample] = {
		0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x99, 0x99, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00,
		0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
		0xcd, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x33, 0xb3, 0x00, 0x00, 0x00, 0x00,
		0x9a, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
	};

	tint iIdx = 3 * c_noChannels;
	tint outputSize = 7 * c_noChannels * c_bytesPerSample;
	tubyte out[7 * c_noChannels * c_bytesPerSample];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

	memset(out, 0, outputSize);
	sampleConverter.convertAtIndex(c_sampleInput, iIdx, out, 7, engine::e_SampleFloat);
	EXPECT_EQ(0, memcmp(c_expectOutput, out, outputSize));
}

//-------------------------------------------------------------------------------------------
/*

	0x100000000 * 0x7fff = 0x00007FFF0000 0000 = 0x7FFF0000
	0x0C0000000 * 0x7fff = 0x00005FFF4000 0000 = 0x5FFF4000
	0x080000000 * 0x7fff = 0x00003FFF8000 0000 = 0x3FFF8000
	0x040000000 * 0x7fff = 0x00001FFFC000 0000 = 0x1FFFC000

	0x0C0000000 * 0x6666 = 0x00004CCC8000 0000 = 0x4CCC8000
	0x080000000 * 0x6666 = 0x000033330000 0000 = 0x33330000
	0x040000000 * 0x6666 = 0x000019998000 0000 = 0x19998000

	0x0C0000000 * 0x4ccc = 0x000039990000 0000 = 0x39990000
	0x080000000 * 0x4ccc = 0x000026660000 0000 = 0x26660000
	0x040000000 * 0x4ccc = 0x000013330000 0000 = 0x13330000

	0x0C0000000 * 0x3333 = 0x000026664000 0000 = 0x26664000
	0x080000000 * 0x3333 = 0x000019998000 0000 = 0x19998000
	0x040000000 * 0x3333 = 0x00000CCCC000 0000 = 0x0CCCC000

	0x0C0000000 * 0x1999 = 0x00001332C000 0000 = 0x1332C000
	0x080000000 * 0x1999 = 0x00000CCC8000 0000 = 0x0CCC8000
	0x040000000 * 0x1999 = 0x000006664000 0000 = 0x06664000

	0x0C0000000 * 0xe667 = 0xFFFFFFFF ECCD4000
	0x080000000 * 0xe667 = 0xFFFFFFFF F3338000
	0x040000000 * 0xe667 = 0xFFFFFFFF F999C000

	0x0C0000000 * 0xcccd = 0xFFFFFFFF D999C000
	0x080000000 * 0xcccd = 0xFFFFFFFF E6668000
	0x040000000 * 0xcccd = 0xFFFFFFFF F3334000

	0x0C0000000 * 0xb334 = 0xFFFFFFFF C6670000
	0x080000000 * 0xb334 = 0xFFFFFFFF D99A0000
	0x040000000 * 0xb334 = 0xFFFFFFFF ECCD0000

	0x0C0000000 * 0x999a = 0xFFFFFFFF B3338000
	0x080000000 * 0x999a = 0xFFFFFFFF CCCD0000
	0x040000000 * 0x999a = 0xFFFFFFFF E6668000

	0x0C0000000 * 0x8001 = 0xFFFFFFFF A000C000
	0x080000000 * 0x8001 = 0xFFFFFFFF C0008000
	0x040000000 * 0x8001 = 0xFFFFFFFF E0004000
	
*/
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,volumeForInt16)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	const tint c_outputSize = c_noSamples * c_noChannels * c_bytesPerSample;

	const tuint16 c_int16Samples[c_noSamples * c_noChannels] = {
		0x7fff, 0x1111,
		0x6666, 0x1111,
		0x4ccc, 0x1111,
		0x3333, 0x1111,
		0x1999, 0x1111,
		0xe667, 0x1111,
		0xcccd, 0x1111,
		0xb334, 0x1111,
		0x999a, 0x1111,
		0x8001, 0x1111,
	};
	
    const tubyte c_expectOutput16_75Percent[c_outputSize] = {
		0x5F, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x4C, 0xCC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x39, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x32, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCD, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xD9, 0x99, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xC6, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xB3, 0x33, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xA0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00
	};

    const tubyte c_expectOutput16_50Percent[c_outputSize] = {
		0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0C, 0xCC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF3, 0x33, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xE6, 0x66, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xD9, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xC0, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
    const tubyte c_expectOutput16_25Percent[c_outputSize] = {
		0x1F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0C, 0xCC, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF9, 0x99, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF3, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xE6, 0x66, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xE0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	tubyte out[c_outputSize];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.75);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int16Samples), out, 10, engine::e_SampleInt16);
    EXPECT_EQ(0, memcmp(c_expectOutput16_75Percent, out, c_outputSize));

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.5);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int16Samples), out, 10, engine::e_SampleInt16);
    EXPECT_EQ(0, memcmp(c_expectOutput16_50Percent, out, c_outputSize));

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.25);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int16Samples), out, 10, engine::e_SampleInt16);
    EXPECT_EQ(0, memcmp(c_expectOutput16_25Percent, out, c_outputSize));
}

//-------------------------------------------------------------------------------------------
/*
	0x100000000 (4294967296) * 0x007fffff ( 8388607) = 0x007FFFFF00000000 = 0x7FFFFF00
	0x0C0000000 (3221225472) * 0x007fffff ( 8388607) = 0x005FFFFF40000000 = 0x5FFFFF40
	0x040000000 (1073741824) * 0x007fffff ( 8388607) = 0x001FFFFFC0000000 = 0x1FFFFFC0

	0x0C0000000 (3221225472) * 0x00666666 ( 6710886) = 0x004CCCCC80000000 = 0x4CCCCC80
	0x040000000 (1073741824) * 0x00666666 ( 6710886) = 0x0019999980000000 = 0x19999980

	0x0C0000000 (3221225472) * 0x004ccccc ( 5033164) = 0x0039999900000000 = 0x39999900
	0x040000000 (1073741824) * 0x004ccccc ( 5033164) = 0x0013333300000000 = 0x13333300

	0x0C0000000 (3221225472) * 0x00333333 ( 3355443) = 0x0026666640000000 = 0x26666640
	0x040000000 (1073741824) * 0x00333333 ( 3355443) = 0x000CCCCCC0000000 = 0x0CCCCCC0

	0x0C0000000 (3221225472) * 0x00199999 ( 1677721) = 0x00133332C0000000 = 0x133332C0
	0x040000000 (1073741824) * 0x00199999 ( 1677721) = 0x0006666640000000 = 0x06666640

	0x0C0000000 (3221225472) * 0xffe66667 (-1677721) = 0xFFECCCCD40000000 = 0xECCCCD40
	0x040000000 (1073741824) * 0xffe66667 (-1677721) = 0xFFF99999C0000000 = 0xF99999C0

	0x0C0000000 (3221225472) * 0xffcccccd (-3355443) = 0xFFD99999C0000000 = 0xD99999C0
	0x040000000 (1073741824) * 0xffcccccd (-3355443) = 0xFFF3333340000000 = 0xF3333340

	0x0C0000000 (3221225472) * 0xffb33334 (-5033164) = 0xFFC6666700000000 = 0xC6666700
	0x040000000 (1073741824) * 0xffb33334 (-5033164) = 0xFFECCCCD00000000 = 0xECCCCD00

	0x0C0000000 (3221225472) * 0xff99999a (-6710886) = 0xFFB3333380000000 = 0xB3333380
	0x040000000 (1073741824) * 0xff99999a (-6710886) = 0xFFE6666680000000 = 0xE6666680

	0x0C0000000 (3221225472) * 0xff800000 (-8388608) = 0xFFA0000000000000 = 0xA0000000
	0x040000000 (1073741824) * 0xff800000 (-8388608) = 0xFFE0000000000000 = 0xE0000000
*/
//-------------------------------------------------------------------------------------------

TEST(SampleConverter,volumeForInt24)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	const tint c_outputSize = c_noSamples * c_noChannels * c_bytesPerSample;

	const tuint32 c_int24Samples[c_noSamples * c_noChannels] = {
		0x007fffff, 0x00111111,
		0x00666666, 0x00111111,
		0x004ccccc, 0x00111111,
		0x00333333, 0x00111111,
		0x00199999, 0x00111111,
		0xffe66667, 0x00111111,
		0xffcccccd, 0x00111111,
		0xffb33334, 0x00111111,
		0xff99999a, 0x00111111,
		0xff800000, 0x00111111
	};
	
    const tubyte c_expectOutput24_75Percent[c_outputSize] = {
		0x5F, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x4C, 0xCC, 0xCC, 0x80, 0x00, 0x00, 0x00, 0x00,
		0x39, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x33, 0x32, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCC, 0xCD, 0x40, 0x00, 0x00, 0x00, 0x00,
		0xD9, 0x99, 0x99, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0xC6, 0x66, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xB3, 0x33, 0x33, 0x80, 0x00, 0x00, 0x00, 0x00,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	
    const tubyte c_expectOutput24_25Percent[c_outputSize] = {
		0x1F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x80, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0C, 0xCC, 0xCC, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x40, 0x00, 0x00, 0x00, 0x00,
		0xF9, 0x99, 0x99, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0xF3, 0x33, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xE6, 0x66, 0x66, 0x80, 0x00, 0x00, 0x00, 0x00,
		0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	tubyte out[c_outputSize];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.75);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int24Samples), out, 10, engine::e_SampleInt24);
    EXPECT_EQ(0, memcmp(c_expectOutput24_75Percent, out, c_outputSize));

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.25);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int24Samples), out, 10, engine::e_SampleInt24);
    EXPECT_EQ(0, memcmp(c_expectOutput24_25Percent, out, c_outputSize));
}

//-------------------------------------------------------------------------------------------
/*
	0x100000000 (4294967296) * 0x7fffffff ( 2147483647) = 0x7FFFFFFF 00000000 = 0x7FFFFFFF
	0x0C0000000 (3221225472) * 0x7fffffff ( 2147483647) = 0x5FFFFFFF 40000000 = 0x5FFFFFFF
	0x040000000 (1073741824) * 0x7fffffff ( 2147483647) = 0x1FFFFFFF C0000000 = 0x20000000

	0x0C0000000 (3221225472) * 0x66666666 ( 1717986918) = 0x4CCCCCCC 80000000 = 0x4CCCCCCD
	0x040000000 (1073741824) * 0x66666666 ( 1717986918) = 0x19999999 80000000 = 0x1999999A

	0x0C0000000 (3221225472) * 0x4ccccccc ( 1288490188) = 0x39999999 00000000 = 0x39999999
	0x040000000 (1073741824) * 0x4ccccccc ( 1288490188) = 0x13333333 00000000 = 0x13333333

	0x0C0000000 (3221225472) * 0x33333333 (  858993459) = 0x26666666 40000000 = 0x26666666
	0x040000000 (1073741824) * 0x33333333 (  858993459) = 0x0CCCCCCC C0000000 = 0x0CCCCCCD

	0x0C0000000 (3221225472) * 0x19999999 (  429496729) = 0x13333332 C0000000 = 0x13333333
	0x040000000 (1073741824) * 0x19999999 (  429496729) = 0x06666666 40000000 = 0x06666666

	0x0C0000000 (3221225472) * 0xe6666667 ( -429496729) = 0xECCCCCCD 40000000 = 0xECCCCCCD
	0x040000000 (1073741824) * 0xe6666667 ( -429496729) = 0xF9999999 C0000000 = 0xF999999A

	0x0C0000000 (3221225472) * 0xcccccccd ( -858993459) = 0xD9999999 C0000000 = 0xD999999A
	0x040000000 (1073741824) * 0xcccccccd ( -858993459) = 0xF3333333 40000000 = 0xF3333333

	0x0C0000000 (3221225472) * 0xb3333334 (-1288490188) = 0xC6666667 00000000 = 0xC6666667
	0x040000000 (1073741824) * 0xb3333334 (-1288490188) = 0xECCCCCCD 00000000 = 0xECCCCCCD

	0x0C0000000 (3221225472) * 0x9999999a (-1717986918) = 0xB3333333 80000000 = 0xB3333334
	0x040000000 (1073741824) * 0x9999999a (-1717986918) = 0xE6666666 80000000 = 0xE6666667

	0x0C0000000 (3221225472) * 0x80000000 (-2147483648) = 0xA0000000 00000000 = 0xA0000000
	0x040000000 (1073741824) * 0x80000000 (-2147483648) = 0xE0000000 00000000 = 0xE0000000
*/

//-------------------------------------------------------------------------------------------

TEST(SampleConverter,volumeForInt32)
{
	const tint c_noBits = 32;
	const tint c_bytesPerSample = 4;
	const bool c_littleEndian = false;
	const bool c_alignHigh = false;
	const bool c_isSigned = true;
	const int c_noSamples = 10;
	const int c_noChannels = 2;
	const tint c_outputSize = c_noSamples * c_noChannels * c_bytesPerSample;

	const tuint32 c_int32Samples[c_noSamples * c_noChannels] = {
		0x7fffffff, 0x11111111,
		0x66666666, 0x11111111,
		0x4ccccccc, 0x11111111,
		0x33333333, 0x11111111,
		0x19999999, 0x11111111,
		0xe6666667, 0x11111111,
		0xcccccccd, 0x11111111,
		0xb3333334, 0x11111111,
		0x9999999a, 0x11111111,
		0x80000000, 0x11111111
	};

    const tubyte c_expectOutput32_75Percent[c_outputSize] = {
		0x5F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
		0x4C, 0xCC, 0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00,
		0x39, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,
		0x26, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCC, 0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00,
		0xD9, 0x99, 0x99, 0x9A, 0x00, 0x00, 0x00, 0x00,
		0xC6, 0x66, 0x66, 0x67, 0x00, 0x00, 0x00, 0x00,
		0xB3, 0x33, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	
    const tubyte c_expectOutput32_25Percent[c_outputSize] = {
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x19, 0x99, 0x99, 0x9A, 0x00, 0x00, 0x00, 0x00,
		0x13, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0x0C, 0xCC, 0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00,
		0x06, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
		0xF9, 0x99, 0x99, 0x9A, 0x00, 0x00, 0x00, 0x00,
		0xF3, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00, 0x00,
		0xEC, 0xCC, 0xCC, 0xCD, 0x00, 0x00, 0x00, 0x00,
		0xE6, 0x66, 0x66, 0x67, 0x00, 0x00, 0x00, 0x00,
		0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	tubyte out[c_outputSize];

	SampleConverter sampleConverter(c_noBits, c_bytesPerSample, c_littleEndian, c_alignHigh, c_isSigned);
	sampleConverter.setNumberOfInputChannels(2);
	sampleConverter.setNumberOfOutputChannels(2);

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.75);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int32Samples), out, 10, engine::e_SampleInt32);
    EXPECT_EQ(0, memcmp(c_expectOutput32_75Percent, out, c_outputSize));

    memset(out, 0, c_outputSize);
	sampleConverter.setVolume(0.25);
	sampleConverter.convert(reinterpret_cast<const sample_t *>(c_int32Samples), out, 10, engine::e_SampleInt32);
    EXPECT_EQ(0, memcmp(c_expectOutput32_25Percent, out, c_outputSize));
}

//-------------------------------------------------------------------------------------------
